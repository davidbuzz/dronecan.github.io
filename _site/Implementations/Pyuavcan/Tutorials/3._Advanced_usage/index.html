<h1 id="advanced-usage">Advanced usage</h1>

<p>This article provides a brief overview of some of the more advanced features of Pyuavcan.
It does not aim to provide an exhaustive user guide; for that you should refer to the
Pythonâ€™s help system (the function <code class="highlighter-rouge">help()</code>) and to the source code,
particularly to the sub-package <code class="highlighter-rouge">uavcan.app</code>.</p>

<p>The examples below assume that the local node instance is bound to the variable <code class="highlighter-rouge">node</code>,
unless stated otherwise.</p>

<h2 id="bus-monitoring">Bus monitoring</h2>

<p>IO hooks allow the application to monitor all incoming and outgoing CAN frames.
The Bus Monitor feature of the GUI Tool is based on this capability of Pyuavcan.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">frame_hook</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">'rx'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'&lt;'</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">'tx'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'Invalid direction specification: </span><span class="si">%</span><span class="s">r'</span> <span class="o">%</span> <span class="n">direction</span><span class="p">)</span>

<span class="n">handle</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">can_driver</span><span class="o">.</span><span class="n">add_io_hook</span><span class="p">(</span><span class="n">frame_hook</span><span class="p">)</span>

<span class="c"># The hook can be removed like that:</span>
<span class="n">handle</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</code></pre>
</div>

<h2 id="file-server">File server</h2>

<p>File server can be used to perform firmware update on remote nodes,
as well as for general purpose file exchange.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">uavcan</span>

<span class="c"># File server need to be provided with file lookup pathes.</span>
<span class="c"># These can be directories or files.</span>
<span class="n">file_server</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">file_server</span><span class="o">.</span><span class="n">FileServer</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[</span><span class="s">'/home/pavel'</span><span class="p">])</span>
<span class="n">file_server</span><span class="o">.</span><span class="n">lookup_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'/etc/fstab'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">file_server</span><span class="o">.</span><span class="n">lookup_paths</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">file_server</span><span class="o">.</span><span class="n">path_hit_counters</span><span class="p">)</span>

<span class="c"># The file server will be running in the background, requiring no additional attention</span>
<span class="c"># When it is no longer needed, it should be finalized by calling close():</span>
<span class="n">file_server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre>
</div>

<p>You can test the file server using the following command in the Interactive Console of the GUI Tool:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">request</span><span class="p">(</span><span class="n">uavcan</span><span class="o">.</span><span class="n">protocol</span><span class="o">.</span><span class="nb">file</span><span class="o">.</span><span class="n">Read</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">uavcan</span><span class="o">.</span><span class="n">protocol</span><span class="o">.</span><span class="nb">file</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s">'/etc/fstab'</span><span class="p">)),</span> <span class="mi">123</span><span class="p">)</span>
</code></pre>
</div>

<p>The file server uses the following logic for relative file path resolution (simplified).
It can be seen that locations specified earlier in the lookup path list take precedence.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># This is simplified</span>
<span class="k">def</span> <span class="nf">_try_resolve_relative_path</span><span class="p">(</span><span class="n">lookup_paths</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lookup_paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">rel_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="dynamic-node-id-allocation">Dynamic node ID allocation</h2>

<p>The logic pertaining to the dynamic node ID allocation feature is located in the module
<code class="highlighter-rouge">uavcan.app.dynamic_node_id</code>.
The code below demonstrates how to run an instance of a centralized node ID allocator.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">node_monitor</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">node_monitor</span><span class="o">.</span><span class="n">NodeMonitor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="c"># It is NOT necessary to specify the database storage.</span>
<span class="c"># If it is not specified, the allocation table will be kept in memory, thus it will not be persistent.</span>
<span class="n">allocator</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">dynamic_node_id</span><span class="o">.</span><span class="n">CentralizedServer</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_monitor</span><span class="p">,</span>
                                                         <span class="n">database_storage</span><span class="o">=</span><span class="s">'/home/pavel/allocation_table.db'</span><span class="p">)</span>

<span class="c"># The allocator and the node monitor will be running in the background, requiring no additional attention</span>
<span class="c"># When they are no longer needed, they should be finalized by calling close():</span>
<span class="n">allocator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">node_monitor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre>
</div>

