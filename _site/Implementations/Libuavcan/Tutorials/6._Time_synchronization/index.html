<h1 id="time-synchronization">Time synchronization</h1>

<p>This advanced-level tutorial shows how to implement network-wide time synchronization with libuavcan.</p>

<p>Two applications are implemented:</p>

<ul>
  <li>Time synchronization slave - a very simple application that synchronizes the local clock with the network time.</li>
  <li>Time synchronization master - a full-featured master that can work with other redundant masters in the same network.
Note that in real applications the masterâ€™s logic can be more complex, for instance,
if the local time source is not always available (e.g. like in GNSS receivers).</li>
</ul>

<p>The reader is highly encouraged to build these example applications and experiment a little:</p>

<ol>
  <li>Start a master and some slaves and see how the slaves synchronize with the master.</li>
  <li>Start more than one master (redundant masters) and see how they interact with each other and how the nodes
converge to the same master.</li>
</ol>

<p>Please note that UAVCAN does not explicitly define algorithms used for clock frequency and phase adjustments,
which are implementation defined.
For instance, the Linux platform driver relies on the kernel function <code class="highlighter-rouge">adjtime()</code> to perform clock adjustments;
other platform drivers may implement a simple PLL.</p>

<p>This tutorial assumes that you have completed the previous tutorials and have a solid understanding
of the time synchronization algorithm defined in the relevant part of the UAVCAN specification.</p>

<h2 id="slave">Slave</h2>

<p>This application implements a time synchronization slave.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cm">/*
 * Implementations for the standard application-level functions are located in uavcan/protocol/.
 * The same path also contains the standard data types uavcan.protocol.*.
 */</span>
<span class="cp">#include &lt;uavcan/protocol/global_time_sync_slave.hpp&gt;
</span>

<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.time_sync_slave"</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Starting the time sync slave.
     * No more than one time sync slave can exist per node.
     * Every time a slave is able to determine the clock phase error, it calls
     * the platform driver method uavcan::ISystemClock::adjustUtc(uavcan::UtcDuration adjustment).
     * Usually, a slave makes an adjustment every second or two, depending on the master's broadcast rate.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalTimeSyncSlave</span> <span class="n">slave</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">slave_init_res</span> <span class="o">=</span> <span class="n">slave</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slave_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the time sync slave; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">slave_init_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Running the node.
     * The time sync slave works in the background and requires no attention at all.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">spin_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spin_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">spin_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Printing the slave status information once a second
         */</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">active</span> <span class="o">=</span> <span class="n">slave</span><span class="p">.</span><span class="n">isActive</span><span class="p">();</span>                      <span class="c1">// Whether it can sync with a remote master
</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">master_node_id</span> <span class="o">=</span> <span class="n">slave</span><span class="p">.</span><span class="n">getMasterNodeID</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>  <span class="c1">// Returns an invalid Node ID if (active == false)
</span>
        <span class="k">const</span> <span class="kt">long</span> <span class="n">msec_since_last_adjustment</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">getMonotonicTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">slave</span><span class="p">.</span><span class="n">getLastAdjustmentTime</span><span class="p">()).</span><span class="n">toMSec</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"Time sync slave status:</span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"    Active: %d</span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"    Master Node ID: %d</span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"    Last clock adjustment was %ld ms ago</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="kt">int</span><span class="p">(</span><span class="n">active</span><span class="p">),</span> <span class="n">master_node_id</span><span class="p">,</span> <span class="n">msec_since_last_adjustment</span><span class="p">);</span>

        <span class="cm">/*
         * Note that libuavcan employs two different time scales:
         *
         * Monotonic time - Represented by the classes uavcan::MonotonicTime and uavcan::MonotonicDuration.
         *                  This time is stable and monotonic; it measures the amount of time since some unspecified
         *                  moment in the past and cannot jump or significantly change rate.
         *                  On Linux it is accessed via clock_gettime(CLOCK_MONOTONIC, ...).
         *
         * UTC time - Represented by the classes uavcan::UtcTime and uavcan::UtcDuration.
         *            This is real time that can be (but is not necessarily) synchronized with the network time.
         *            This time is not stable in the sense that it can change rate and jump forward and backward
         *            in order to eliminate the difference with the global network time.
         *            Note that, despite its name, this time scale does not need to be strictly UTC, although it
         *            is recommended.
         *            On Linux it is accessed via gettimeofday(...).
         *
         * Both clocks are accessible via the methods INode::getMonotonicTime() and INode::getUtcTime().
         *
         * Note that the time representation is type safe as it is impossible to mix UTC and monotonic time in
         * the same expression (compilation will fail).
         */</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicTime</span> <span class="n">mono_time</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">getMonotonicTime</span><span class="p">();</span>

        <span class="n">uavcan</span><span class="o">::</span><span class="n">UtcTime</span> <span class="n">utc_time</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">getUtcTime</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"Current time in seconds: Monotonic: %s   UTC: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">mono_time</span><span class="p">.</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">utc_time</span><span class="p">.</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>

        <span class="n">mono_time</span> <span class="o">+=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromUSec</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>

        <span class="n">utc_time</span> <span class="o">+=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">UtcDuration</span><span class="o">::</span><span class="n">fromUSec</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"1234 usec later: Monotonic: %s   UTC: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">mono_time</span><span class="p">.</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">utc_time</span><span class="p">.</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="master">Master</h2>

<p>This application implements a time synchronization master.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cm">/*
 * Implementations for the standard application-level functions are located in uavcan/protocol/.
 * The same path also contains the standard data types uavcan.protocol.*.
 */</span>
<span class="cp">#include &lt;uavcan/protocol/global_time_sync_master.hpp&gt;
#include &lt;uavcan/protocol/global_time_sync_slave.hpp&gt;
</span>

<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.time_sync_master"</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing the time sync master object.
     * No more than one time sync master can exist per node.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalTimeSyncMaster</span> <span class="n">master</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">master_init_res</span> <span class="o">=</span> <span class="n">master</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">master_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the time sync master; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">master_init_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * A time sync master should be able to properly cooperate with redundant masters present in the
     * network - if there's a higher priority master, we need to switch to a slave mode and sync with that master.
     * Here we start a time sync slave for this purpose.
     * Remember that no more than one time sync slave can exist per node.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalTimeSyncSlave</span> <span class="n">slave</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">slave_init_res</span> <span class="o">=</span> <span class="n">slave</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slave_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the time sync slave; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">slave_init_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Create a timer to publish the time sync message once a second.
     * Note that in real applications the logic governing time sync master can be even more complex,
     * i.e. if the local time source is not always available (like in GNSS receivers).
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Timer</span> <span class="n">master_timer</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">master_timer</span><span class="p">.</span><span class="n">setCallback</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerEvent</span><span class="o">&amp;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/*
             * Check whether there are higher priority masters in the network.
             * If there are, we need to activate the local slave in order to sync with them.
             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">.</span><span class="n">isActive</span><span class="p">())</span>  <span class="c1">// "Active" means that the slave tracks at least one remote master in the network
</span>            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">getNodeID</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">slave</span><span class="p">.</span><span class="n">getMasterNodeID</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="cm">/*
                     * We're the highest priority master in the network.
                     * We need to suppress the slave now to prevent it from picking up unwanted sync messages from
                     * lower priority masters.
                     */</span>
                    <span class="n">slave</span><span class="p">.</span><span class="n">suppress</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  <span class="c1">// SUPPRESS
</span>                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am the highest priority master; the next one has Node ID "</span>
                              <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">slave</span><span class="p">.</span><span class="n">getMasterNodeID</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="cm">/*
                     * There is at least one higher priority master in the network.
                     * We need to allow the slave to adjust our local clock in order to be in sync.
                     */</span>
                    <span class="n">slave</span><span class="p">.</span><span class="n">suppress</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// UNSUPPRESS
</span>                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Syncing with a higher priority master with Node ID "</span>
                              <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">slave</span><span class="p">.</span><span class="n">getMasterNodeID</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="cm">/*
                 * There are no other time sync masters in the network, so we're the only time source.
                 * The slave must be suppressed anyway to prevent it from disrupting the local clock if a new
                 * lower priority master suddenly appears in the network.
                 */</span>
                <span class="n">slave</span><span class="p">.</span><span class="n">suppress</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"No other masters detected in the network"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/*
             * Publish the sync message now, even if we're not a higher priority master.
             * Other nodes will be able to pick the right master anyway.
             */</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">master</span><span class="p">.</span><span class="n">publish</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Time sync master transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">});</span>

    <span class="n">master_timer</span><span class="p">.</span><span class="n">startPeriodic</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

    <span class="cm">/*
     * Running the node.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">spin_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">getInfinite</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spin_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">spin_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="running-on-linux">Running on Linux</h2>

<p>Build the applications using the following CMake script:</p>

<div class="language-cmake highlighter-rouge"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>tutorial_project<span class="p">)</span>

<span class="nb">find_library</span><span class="p">(</span>UAVCAN_LIB uavcan REQUIRED<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"-Wall -Wextra -pedantic -std=c++11"</span><span class="p">)</span>

<span class="c1"># Make sure to provide correct path to 'platform_linux.cpp'! See earlier tutorials for more info.</span>
<span class="nb">add_executable</span><span class="p">(</span>slave slave.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>slave <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>master master.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>master <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>

</code></pre>
</div>
