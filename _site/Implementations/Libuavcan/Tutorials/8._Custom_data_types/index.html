<h1 id="custom-data-types">Custom data types</h1>

<p>This tutorial covers how to define and use vendor-specific data types (DSDL definitions).</p>

<p>The following topics are explained:</p>

<ul>
  <li>How to define a vendor-specific data type.</li>
  <li>How to allow the end user to assign/override a data type ID for a certain type.</li>
  <li>How to invoke the DSDL compiler to generate C++ headers for custom data types.</li>
</ul>

<p>Two applications are implemented in this tutorial:</p>

<ul>
  <li>Server - the node that provides two vendor-specific services.</li>
  <li>Client - the node that calls the vendor-specific services provided by the server.</li>
</ul>

<p>This tutorial requires the reader to be familiar with UAVCAN specification and
to have completed all the basic tutorials.</p>

<h2 id="defining-data-types">Defining data types</h2>

<h3 id="abstract">Abstract</h3>

<p>Suppose we have a vendor named “Sirius Cybernetics Corporation” for whom
we need to define the following vendor-specific data types:</p>

<ul>
  <li><code class="highlighter-rouge">sirius_cybernetics_corporation.GetCurrentTime</code> - returns the current time on the server.
The default data type ID for this service is 242.</li>
  <li><code class="highlighter-rouge">sirius_cybernetics_corporation.PerformLinearLeastSquaresFit</code> -
accepts a set of 2D coordinates and returns the coefficients for the best-fit linear function.
This service does not have a default data type ID.</li>
</ul>

<p>Note that both data types are located in the namespace <code class="highlighter-rouge">sirius_cybernetics_corporation</code>,
which unambiguously indicates that these types are defined by Sirius Cybernetics Corporation and
allows to avoid name clashing if similarly named data types from different vendors are used in the same application.
Note that, according to the naming requirements, name of a DSDL namespace must start with an alphabetic character;
therefore, a company whose name starts with a digit will have to resort to a mangled name
(e.g., “42 Computing” → <code class="highlighter-rouge">fourtytwo_computing</code>, or <code class="highlighter-rouge">computing42</code>, etc.).</p>

<p>Even though this tutorial deals with service types,
the same concepts and procedures are also applicable to message types.
The reader is encouraged to extend this tutorial with at least one vendor-specific message data type.</p>

<h3 id="the-procedure">The procedure</h3>

<p>As explained in the specification, a namespace for DSDL definitions is just a directory,
so we need to create a directory named <code class="highlighter-rouge">sirius_cybernetics_corporation</code>.
This directory can be placed anywhere; normally you’d probably want to put it in your project’s root directory,
as we’ll do in this tutorial.
You should not create it inside the libuavcan’s DSDL directory (<code class="highlighter-rouge">libuavcan/dsdl/...</code>)
in order to not pollute the libuavcan’s source tree with your custom data types.</p>

<p>In the newly created directory, place the following DSDL definition in a file named <code class="highlighter-rouge">242.GetCurrentTime.uavcan</code>:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c">#</span>
<span class="c"># This service accepts nothing and returns the current time on the server node.</span>
<span class="c">#</span>
<span class="c"># All DSDL definitions should contain a header comment (like this one) that</span>
<span class="c"># explains what this data type is designed for and how to use it.</span>
<span class="c">#</span>

<span class="c"># This service does not accept any parameters, so the request part is empty</span>

<span class="o">---</span>

<span class="c"># Current time.</span>
<span class="c"># Note that the data type "uavcan.Timestamp" is defined by the UAVCAN specification.</span>
<span class="n">uavcan</span><span class="o">.</span><span class="n">Timestamp</span> <span class="n">time</span>

</code></pre>
</div>

<p>Note that the filename starts with the number 242 followed by a dot,
which tells the DSDL compiler that the default data type ID for this type is 242.
You can learn more about naming in the relevant part of the specification.</p>

<p>In the same directory, place the following DSDL definition in a file named <code class="highlighter-rouge">PerformLinearLeastSquaresFit.uavcan</code>:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c">#</span>
<span class="c"># This service accepts a dynamic array of 2D coordinates and returns</span>
<span class="c"># the coefficients for the best-fit linear function.</span>
<span class="c">#</span>
<span class="c"># This service doesn't have a default Data Type ID.</span>
<span class="c">#</span>

<span class="n">PointXY</span><span class="p">[</span><span class="o">&lt;</span><span class="mi">64</span><span class="p">]</span> <span class="n">points</span>

<span class="o">---</span>

<span class="n">float64</span> <span class="n">slope</span>
<span class="n">float64</span> <span class="n">y_intercept</span>

</code></pre>
</div>

<p>Now, observe that the definition above refers to the data type <code class="highlighter-rouge">PointXY</code>.
Let’s define it - place the following in a file named <code class="highlighter-rouge">PointXY.uavcan</code>:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c">#</span>
<span class="c"># This nested type contains 2D point coordinates.</span>
<span class="c">#</span>

<span class="n">float16</span> <span class="n">x</span>
<span class="n">float16</span> <span class="n">y</span>

</code></pre>
</div>

<h3 id="compiling">Compiling</h3>

<p>Normally, the compilation should be performed by the build system, which is explained later in this tutorial.
For the sake of a demonstration, let’s compile the data types defined above by manually invoking the DSDL compiler.</p>

<p>If the host OS is Linux and libuavcan is installed, the following command can be used:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ libuavcan_dsdlc ./sirius_cybernetics_corporation -I/usr/local/share/uavcan/dsdl/uavcan
</code></pre>
</div>

<p>Alternatively, if the library is not installed, use relative paths
(the command invocation example below assumes that the libuavcan directory and
our vendor-specific namespace directory are both located in the project’s root):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ libuavcan/libuavcan/dsdl_compiler/libuavcan_dsdlc ./sirius_cybernetics_corporation -Iuavcan/dsdl/uavcan/
</code></pre>
</div>

<p>Note that if the output directory is not specified explicitly via the command line option <code class="highlighter-rouge">--outdir</code> or <code class="highlighter-rouge">-O</code>,
the default will be used, which is <code class="highlighter-rouge">./dsdlc_generated</code>.
It is recommended to exclude the output directory from version control,
e.g. for git, add <code class="highlighter-rouge">dsdlc_generated</code> to the <code class="highlighter-rouge">.gitignore</code> config file.</p>

<h2 id="the-code">The code</h2>

<h3 id="server">Server</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cp">#include &lt;uavcan/protocol/debug/LogMessage.hpp&gt;      // For purposes of example; not actually necessary.
</span>
<span class="cm">/*
 * The custom data types.
 * If a data type has a default Data Type ID, it will be registered automatically once included
 * (the registration will be done before main() from a static constructor).
 */</span>
<span class="cp">#include &lt;sirius_cybernetics_corporation/GetCurrentTime.hpp&gt;
#include &lt;sirius_cybernetics_corporation/PerformLinearLeastSquaresFit.hpp&gt;
</span>
<span class="k">using</span> <span class="n">sirius_cybernetics_corporation</span><span class="o">::</span><span class="n">GetCurrentTime</span><span class="p">;</span>
<span class="k">using</span> <span class="n">sirius_cybernetics_corporation</span><span class="o">::</span><span class="n">PerformLinearLeastSquaresFit</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.custom_dsdl_server"</span><span class="p">);</span>

    <span class="cm">/*
     * We defined two data types, but only one of them has a default Data Type ID (DTID):
     *  - sirius_cybernetics_corporation.GetCurrentTime               - default DTID 242
     *  - sirius_cybernetics_corporation.PerformLinearLeastSquaresFit - default DTID is not set
     * The first one can be used as is; the second one needs to be registered first.
     */</span>
    <span class="k">auto</span> <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">PerformLinearLeastSquaresFit</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">243</span><span class="p">);</span> <span class="c1">// DTID = 243
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">regist_result</span> <span class="o">!=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultOk</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/*
         * Possible reasons for a failure:
         * - Data type name or ID is not unique
         * - Data Type Registry has been frozen and can't be modified anymore
         */</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to register the data type: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">regist_result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Now we can use both data types:
     *  - sirius_cybernetics_corporation.GetCurrentTime               - DTID 242
     *  - sirius_cybernetics_corporation.PerformLinearLeastSquaresFit - DTID 243
     *
     * But here's more:
     * The specification requires that "the end user must be able to change the ID of any non-standard data type".
     * So assume that the end user needs to change the default value of 242 to 211. No problem, as long as the
     * Data Type Registry is not frozen. Once frozen, the registry can't alter the established data type configuration
     * anymore.
     *
     * Note that non-default Data Type IDs should normally be kept as node configuration params to make them easily
     * accessible for the user. Please refer to the relevant tutorial to learn how to make the node configuration
     * accessible via UAVCAN.
     * Also, this part of the specification is highly relevant - it describes parameter naming conventions for DTID:
     *  https://uavcan.org/Specification/6._Application_level_functions/#node-configuration
     */</span>
    <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span>  <span class="c1">// DTID: 242 --&gt; 211
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">regist_result</span> <span class="o">!=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultOk</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to register the data type: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">regist_result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * The DTID of standard types can be changed also.
     */</span>
    <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">debug</span><span class="o">::</span><span class="n">LogMessage</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">20999</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">regist_result</span> <span class="o">!=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultOk</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to register the data type: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">regist_result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * The current configuration is as follows:
     *  - sirius_cybernetics_corporation.GetCurrentTime                - DTID 211
     *  - sirius_cybernetics_corporation.PerformLinearLeastSquaresFit  - DTID 243
     *  - uavcan.protocol.debug.LogMessage                             - DTID 20999
     * Let's check it.
     * We can query data type info either by full name or by data type ID using the method find().
     * If there's no such type, find() returns nullptr.
     */</span>
    <span class="k">auto</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"sirius_cybernetics_corporation.GetCurrentTime"</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span> <span class="o">==</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">DataTypeID</span><span class="p">(</span><span class="mi">211</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span> <span class="o">!=</span> <span class="n">GetCurrentTime</span><span class="o">::</span><span class="n">DefaultDataTypeID</span><span class="p">);</span> <span class="c1">// There's a T::DefaultDataTypeID if the default DTID is set
</span>
    <span class="n">descriptor</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">DataTypeKindService</span><span class="p">,</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">DataTypeID</span><span class="p">(</span><span class="mi">243</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">getFullName</span><span class="p">())</span> <span class="o">==</span> <span class="s">"sirius_cybernetics_corporation.PerformLinearLeastSquaresFit"</span><span class="p">);</span>

    <span class="n">descriptor</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"uavcan.protocol.debug.LogMessage"</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span> <span class="o">==</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">DataTypeID</span><span class="p">(</span><span class="mi">20999</span><span class="p">));</span>

    <span class="cm">/*
     * Starting the node as usual.
     * The Data Type Registry will be frozen once the node is started, then it can't be unfrozen again.
     */</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Warning: you can't change the data type configuration once the node is started because the Data Type Registry
     * is frozen now.
     */</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">isFrozen</span><span class="p">());</span> <span class="c1">// It is frozen indeed.
</span>
    <span class="cm">/*
     * Don't try this at home.
     */</span>
    <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetCurrentTime</span><span class="o">::</span><span class="n">DefaultDataTypeID</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">regist_result</span> <span class="o">==</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultFrozen</span><span class="p">);</span>   <span class="c1">// Will fail.
</span>
    <span class="cm">/*
     * Now we can start the services.
     * There's nothing unusual at all.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceServer</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;</span> <span class="n">srv_get_current_time</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">srv_get_current_time</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">GetCurrentTime</span><span class="o">::</span><span class="n">Request</span><span class="o">&amp;</span> <span class="n">request</span><span class="p">,</span> <span class="n">GetCurrentTime</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">request</span><span class="p">;</span> <span class="c1">// It's empty
</span>            <span class="n">response</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">getUtcTime</span><span class="p">();</span>  <span class="c1">// Note: uavcan::UtcTime implicitly converts to uavcan.Timestamp!
</span>        <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the GetCurrentTime server: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceServer</span><span class="o">&lt;</span><span class="n">PerformLinearLeastSquaresFit</span><span class="o">&gt;</span> <span class="n">srv_least_squares</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">srv_least_squares</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">PerformLinearLeastSquaresFit</span><span class="o">::</span><span class="n">Request</span><span class="o">&amp;</span> <span class="n">request</span><span class="p">,</span> <span class="n">PerformLinearLeastSquaresFit</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> <span class="n">sum_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_xy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">point</span> <span class="o">:</span> <span class="n">request</span><span class="p">.</span><span class="n">points</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">sum_x</span> <span class="o">+=</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
                <span class="n">sum_y</span> <span class="o">+=</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
                <span class="n">sum_xy</span> <span class="o">+=</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
                <span class="n">sum_xx</span> <span class="o">+=</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_x</span> <span class="o">*</span> <span class="n">sum_y</span> <span class="o">-</span> <span class="n">request</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">sum_xy</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sum_x</span> <span class="o">*</span> <span class="n">sum_x</span> <span class="o">-</span> <span class="n">request</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">sum_xx</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">response</span><span class="p">.</span><span class="n">slope</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
                <span class="n">response</span><span class="p">.</span><span class="n">y_intercept</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_y</span> <span class="o">-</span> <span class="n">response</span><span class="p">.</span><span class="n">slope</span> <span class="o">*</span> <span class="n">sum_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">request</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the PerformLinearLeastSquaresFit server: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Running the node as usual.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">getInfinite</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="client">Client</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cm">/*
 * The custom data types.
 */</span>
<span class="cp">#include &lt;sirius_cybernetics_corporation/GetCurrentTime.hpp&gt;
#include &lt;sirius_cybernetics_corporation/PerformLinearLeastSquaresFit.hpp&gt;
</span>
<span class="k">using</span> <span class="n">sirius_cybernetics_corporation</span><span class="o">::</span><span class="n">GetCurrentTime</span><span class="p">;</span>
<span class="k">using</span> <span class="n">sirius_cybernetics_corporation</span><span class="o">::</span><span class="n">PerformLinearLeastSquaresFit</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt; &lt;remote-node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">remote_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.custom_dsdl_client"</span><span class="p">);</span>

    <span class="cm">/*
     * Configuring the Data Type IDs.
     * See the server sources for details.
     */</span>
    <span class="k">auto</span> <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">PerformLinearLeastSquaresFit</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">243</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">regist_result</span> <span class="o">!=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultOk</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to register the data type: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">regist_result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">regist_result</span> <span class="o">=</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">registerDataType</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">regist_result</span> <span class="o">!=</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">GlobalDataTypeRegistry</span><span class="o">::</span><span class="n">RegistrationResultOk</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to register the data type: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">regist_result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Starting the node
     */</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Calling both services once; the result will be printed to stdout as YAML.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceClient</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;</span> <span class="n">cln_time</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">cln_time</span><span class="p">.</span><span class="n">setCallback</span><span class="p">([](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceCallResult</span><span class="o">&lt;</span><span class="n">GetCurrentTime</span><span class="o">&gt;&amp;</span> <span class="n">res</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cln_time</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">remote_node_id</span><span class="p">,</span> <span class="n">GetCurrentTime</span><span class="o">::</span><span class="n">Request</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to call GetCurrentTime: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceClient</span><span class="o">&lt;</span><span class="n">PerformLinearLeastSquaresFit</span><span class="o">&gt;</span> <span class="n">cln_least_squares</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">cln_least_squares</span><span class="p">.</span><span class="n">setCallback</span><span class="p">([](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceCallResult</span><span class="o">&lt;</span><span class="n">PerformLinearLeastSquaresFit</span><span class="o">&gt;&amp;</span> <span class="n">res</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="n">PerformLinearLeastSquaresFit</span><span class="o">::</span><span class="n">Request</span> <span class="n">request</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sirius_cybernetics_corporation</span><span class="o">::</span><span class="n">PointXY</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">2.5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">request</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">cln_least_squares</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">remote_node_id</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to call PerformLinearLeastSquaresFit: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Spinning the node until both calls are finished.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cln_time</span><span class="p">.</span><span class="n">hasPendingCalls</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cln_least_squares</span><span class="p">.</span><span class="n">hasPendingCalls</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="building">Building</h2>

<p>This example shows how to build the above applications and compile the vendor-specific data types using CMake.
It’s quite easy to adapt it to other platforms and build systems - use the
<a href="https://www.google.com/?q=site%3Agithub.com%20%2B%22uavcan%22%20%22Makefile%22">existing projects</a> as a reference.</p>

<p>It is assumed that the libuavcan directory and our vendor-specific namespace directory are both located
in the project’s root, although it is not necessary.</p>

<p><code class="highlighter-rouge">CMakeLists.txt</code>:</p>

<div class="language-cmake highlighter-rouge"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>tutorial_project<span class="p">)</span>

<span class="nb">find_library</span><span class="p">(</span>UAVCAN_LIB uavcan REQUIRED<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"-Wall -Wextra -std=c++11"</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># For the next step, we're going to need to know where the standard DSDL definitions are located.</span>
<span class="c1">#</span>
<span class="c1"># For the sake of simplicity, this example assumes that the OS we're working on is Linux, so</span>
<span class="c1"># we can use the default installation directory for DSDL definitions in /usr/local/share/.</span>
<span class="c1">#</span>
<span class="c1"># If you're using it on an embedded system or if the library isn't installed in the host OS,</span>
<span class="c1"># use a relative path to the DSDL subproject.</span>
<span class="c1">#</span>
<span class="nb">set</span><span class="p">(</span>UAVCAN_DSDL_DEFINITIONS <span class="s2">"/usr/local/share/uavcan/dsdl/uavcan"</span><span class="p">)</span>      <span class="c1"># For Linux, if the library is installed</span>

<span class="c1"># If the library is not installed on the host OS, use relative path to the standard DSDL definitions, for example:</span>
<span class="c1">#set(UAVCAN_DSDL_DEFINITIONS "dsdl/uavcan")</span>

<span class="c1">#</span>
<span class="c1"># Invoke the DSDL compiler to generate headers for our custom data types.</span>
<span class="c1"># The default output directory is "dsdlc_generated"; it can be overridden if needed.</span>
<span class="c1"># If libuavcan is installed, we can use directly the compiler's executable "libuavcan_dsdlc".</span>
<span class="c1"># If the library isn't installed, use a relative path to the compiler in the libuavcan source tree.</span>
<span class="c1">#</span>
<span class="nb">add_custom_target</span><span class="p">(</span>dsdlc libuavcan_dsdlc                                      <span class="c1"># If the library is installed</span>
                  <span class="s2">"./sirius_cybernetics_corporation"</span> -I<span class="si">${</span><span class="nv">UAVCAN_DSDL_DEFINITIONS</span><span class="si">}</span>
                  WORKING_DIRECTORY <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span><span class="p">)</span>

<span class="c1"># Using relative path to the DSDL compiler if the library is not installed:</span>
<span class="c1">#add_custom_target(dsdlc libuavcan/libuavcan/dsdl_compiler/libuavcan_dsdlc</span>
<span class="c1">#                  "./sirius_cybernetics_corporation" -I${UAVCAN_DSDL_DEFINITIONS}</span>
<span class="c1">#                  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="s2">"dsdlc_generated"</span><span class="p">)</span> <span class="c1"># Adding the default output directory to the include paths</span>

<span class="c1">#</span>
<span class="c1"># Side note:</span>
<span class="c1"># A possible way to invoke the DSDL compiler using plain make is the following:</span>
<span class="c1">#       include libuavcan/libuavcan/include.mk</span>
<span class="c1">#       $(info $(shell $(LIBUAVCAN_DSDLC) $(UAVCAN_DSDL_DIR) "./sirius_cybernetics_corporation"))</span>
<span class="c1"># Assuming that the library is not installed.</span>
<span class="c1"># Don't forget to add "dsdlc_generated" to the include directories.</span>
<span class="c1">#</span>

<span class="c1">#</span>
<span class="c1"># Client and server targets.</span>
<span class="c1"># Note that both depend on the dsdlc target.</span>
<span class="c1"># Make sure to provide correct path to 'platform_linux.cpp'! See earlier tutorials for more info.</span>
<span class="c1">#</span>
<span class="nb">add_executable</span><span class="p">(</span>server server.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>server <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>
<span class="nb">add_dependencies</span><span class="p">(</span>server dsdlc<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>client client.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>client <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>
<span class="nb">add_dependencies</span><span class="p">(</span>client dsdlc<span class="p">)</span>

</code></pre>
</div>

<h2 id="running">Running</h2>

<p>These instructions assume a Linux environment.
First, make sure that the system has at least one CAN interface.
You may want to refer to the first tutorials to learn how to add a virtual CAN interface on Linux.</p>

<p>Running the server with node ID 111:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./server 111
</code></pre>
</div>

<p>The server just sits there waiting for requests, not doing anything on its own.
Start another terminal and execute the client with node ID 112:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./client 112 111
</code></pre>
</div>

<p>The client should print something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Service call result [sirius_cybernetics_corporation.GetCurrentTime] OK server_node_id=111 tid=0
# Received struct ts_m=25935.913686 ts_utc=1442844327.400572 snid=111
time:
  usec: 1442844327400560
# Service call result [sirius_cybernetics_corporation.PerformLinearLeastSquaresFit] OK server_node_id=111 tid=0
# Received struct ts_m=25935.913891 ts_utc=1442844327.400725 snid=111
slope: 0.4
y_intercept: -4

</code></pre>
</div>

<p>Now, execute the client providing a non-existent server Node ID and see what happens:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./client 112 1
# Service call result [sirius_cybernetics_corporation.GetCurrentTime] FAILURE server_node_id=1 tid=0
# (no data)
# Service call result [sirius_cybernetics_corporation.PerformLinearLeastSquaresFit] FAILURE server_node_id=1 tid=0
# (no data)
</code></pre>
</div>
