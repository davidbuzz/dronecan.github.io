<h1 id="can-acceptance-filters">CAN acceptance filters</h1>

<p>One of the most significant features of a CAN protocol controller is the acceptance filtering capability. Most of CAN 
implementations provide some hardware acceptance filters to relieve the microcontroller from the task of filtering 
those messages which are needed from those which are not of interest.</p>

<p>You can read more about CAN hardware acceptance filters in
<a href="http://www.inp.nsk.su/~kozak/canbus/canimpl.pdf">this article</a>, page 25-28.</p>

<h2 id="operation-principle">Operation principle</h2>

<p>Diagram below shows how hardware acceptance filters work within CAN protocol:</p>

<p><a class="imagelink" href="/Implementations/Libuavcan/Tutorials/13._CAN_acceptance_filters/acceptance_filters_scheme.png" data-lightbox="/Implementations/Libuavcan/Tutorials/13._CAN_acceptance_filters/acceptance_filters_scheme.png" data-title="CAN acceptance filtering">
<img src="/Implementations/Libuavcan/Tutorials/13._CAN_acceptance_filters/acceptance_filters_scheme.png" class="" style="" />
</a></p>

<h2 id="example">Example</h2>

<h3 id="publisherclient-node">Publisher/Client node</h3>

<p>This application will be constantly sending messages and service requests to the subscriber/server node (below).
It will help to better understand how hardware acceptance filters work and how to properly configure them using
libuavcan.</p>

<p>Put the following code into <code class="highlighter-rouge">publisher_client.cpp</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cp">#include &lt;uavcan/protocol/file/BeginFirmwareUpdate.hpp&gt;
#include &lt;uavcan/equipment/air_data/Sideslip.hpp&gt;
#include &lt;uavcan/equipment/air_data/TrueAirspeed.hpp&gt;
</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">Node</span><span class="p">;</span>


<span class="k">static</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">getNode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Node</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt; &lt;server-node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing a new node. Refer to the "Node initialization and startup" tutorial for more details.
     */</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">server_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">getNode</span><span class="p">();</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.publisher"</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing publishers. Please refer to the "Publishers and subscribers" tutorial for more details.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Publisher</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">Sideslip</span><span class="o">&gt;</span> <span class="n">sideslip_pub</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">sideslip_pub_init_res</span> <span class="o">=</span> <span class="n">sideslip_pub</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sideslip_pub_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the publisher; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">sideslip_pub_init_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">Publisher</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">TrueAirspeed</span><span class="o">&gt;</span> <span class="n">airspeed_pub</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">airspeed_pub_init_res</span> <span class="o">=</span> <span class="n">airspeed_pub</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">airspeed_pub_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the publisher; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">airspeed_pub_init_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing service client. Please refer to the "Services" tutorial for more details.
     */</span>
    <span class="k">using</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="p">;</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceClient</span><span class="o">&lt;</span><span class="n">BeginFirmwareUpdate</span><span class="o">&gt;</span> <span class="n">client</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">client_init_res</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">client_init_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to init the client; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">client_init_res</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">client</span><span class="p">.</span><span class="n">setCallback</span><span class="p">([](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceCallResult</span><span class="o">&lt;</span><span class="n">BeginFirmwareUpdate</span><span class="o">&gt;&amp;</span> <span class="n">call_result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">call_result</span><span class="p">.</span><span class="n">isSuccessful</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">call_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Service call to node "</span>
                      <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">call_result</span><span class="p">.</span><span class="n">getCallID</span><span class="p">().</span><span class="n">server_node_id</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
                      <span class="o">&lt;&lt;</span> <span class="s">" has failed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="n">client</span><span class="p">.</span><span class="n">setRequestTimeout</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>

    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/*
         * Constantly publishing messages and sending requests to the server.
         */</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">spin_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spin_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">spin_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">Sideslip</span> <span class="n">sideslip_msg</span><span class="p">;</span>
        <span class="n">sideslip_msg</span><span class="p">.</span><span class="n">sideslip_angle</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="n">sideslip_msg</span><span class="p">.</span><span class="n">sideslip_angle_variance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">sideslip_msg_pub_res</span> <span class="o">=</span> <span class="n">sideslip_pub</span><span class="p">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">sideslip_msg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sideslip_msg_pub_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"KV publication failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">sideslip_msg_pub_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">TrueAirspeed</span> <span class="n">airspd_msg</span><span class="p">;</span>
        <span class="n">airspd_msg</span><span class="p">.</span><span class="n">true_airspeed</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">airspd_msg</span><span class="p">.</span><span class="n">true_airspeed_variance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">airspd_msg_pub_res</span> <span class="o">=</span> <span class="n">airspeed_pub</span><span class="p">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">airspd_msg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">airspd_msg_pub_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"KV publication failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">airspd_msg_pub_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Request</span> <span class="n">request</span><span class="p">;</span>
        <span class="n">request</span><span class="p">.</span><span class="n">image_file_remote_path</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/foo/bar"</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">call_res</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">server_node_id</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">call_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Unable to perform service call: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">call_res</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="subscriberserver-node">Subscriber/Server node</h3>

<p>This application demonstrates how to configure hardware acceptance filters with libuavcan.</p>

<p>Put the following code into <code class="highlighter-rouge">subscriber_server.cpp</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
#include &lt;uavcan/transport/can_acceptance_filter_configurator.hpp&gt;
</span>
<span class="cp">#include &lt;uavcan/protocol/file/BeginFirmwareUpdate.hpp&gt;
#include &lt;uavcan/equipment/air_data/Sideslip.hpp&gt;
#include &lt;uavcan/equipment/air_data/TrueAirspeed.hpp&gt;
</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">NodeMemoryPoolSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">NodeMemoryPoolSize</span><span class="o">&gt;</span> <span class="n">Node</span><span class="p">;</span>

<span class="k">static</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">getNode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Node</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/*
     * Initializing a new node. Refer to the "Node initialization and startup" tutorial for more details.
     */</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">getNode</span><span class="p">();</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.subscriber"</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/**
     * The most common way to configure CAN hardware acceptance filters is just to use configureCanAcceptanceFilters()
     * method with a node you want to configure as an input argument. This method usually called after all the node's
     * subscribers have been declared and it calls computeConfiguration() and applyConfiguration() subsequently (these
     * functions will be described later in this tutorial).
     * At this point your HW filters will be configured to accept all service messages (always accepted by UAVCAN) and
     * anonymous messages, since we don't have any subscribers declared so far. You may already
     * execute publisher_client which will constantly send messages to this node.
     */</span>
    <span class="n">configureCanAcceptanceFilters</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/**
     * Initializing a subscriber uavcan::equipment::air_data::Sideslip. Please refer to the "Publishers and subscribers"
     * tutorial for more details.
     * We are still not getting any messages from publisher_client node, since the air_data::Sideslip was declared after
     * acceptance filters have been configured.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">Sideslip</span><span class="o">&gt;</span> <span class="n">sideslip_sub</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">sideslip_sub_start_res</span> <span class="o">=</span> <span class="n">sideslip_sub</span><span class="p">.</span><span class="n">start</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">Sideslip</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sideslip_sub_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the key/value subscriber; error: "</span> <span class="o">+</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">sideslip_sub_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Will not receive air_data::Sideslip messages for another 3 seconds until we reconfigure acceptance filters and
     * include another configuration for the message. As soon as filters are reconfigured the node will start to
     * receive the air_data::Sideslip messages.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">3000</span><span class="p">));</span> <span class="c1">// Wait 3 seconds
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Reconfiguring acceptance filters ..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">configureCanAcceptanceFilters</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/**
     * In case you need to create custom configuration of hardware acceptance filters, or if you want to output your
     * computed configurations, the following approach should be used.
     *
     * The first step to configure CAN hardware acceptance filters is to create an object of class
     * uavcan::CanAcceptanceFilterConfigurator with the desired node as an input argument.
     *
     * NOTICE: Only for this tutorial we are going to put the second argument, which overrides the actual number
     * of available hardware filters to 6. You are highly unlikely to ever need this feature - it's only provided to
     * make this tutorial more illustrative.
     * There is also MaxCanAcceptanceFilters parameter in libuavcan/include/uavcan/build_config.hpp that limits the
     * maximum number of CAN acceptance filters available on the platform. You may increase this number manually if
     * your platform provides more filters and you want to use all of them (there are very few CAN controllers that
     * feature more than 32 filters though, if any).
     *
     * This object haven't configured anything yet, in order to make the configuration proceed to the
     * next step.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">CanAcceptanceFilterConfigurator</span> <span class="n">anon_test_configuration</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">6</span><span class="cm">/* not needed in real apps */</span><span class="p">);</span>

    <span class="cm">/*
     * Initializing another subscriber uavcan::equipment::air_data::TrueAirspeed.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">TrueAirspeed</span><span class="o">&gt;</span> <span class="n">airspd_sub</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">airspd_sub_sub_start_res</span> <span class="o">=</span> <span class="n">airspd_sub</span><span class="p">.</span><span class="n">start</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">equipment</span><span class="o">::</span><span class="n">air_data</span><span class="o">::</span><span class="n">TrueAirspeed</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">airspd_sub_sub_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the key/value subscriber; error: "</span>
                                 <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">airspd_sub_sub_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing service server. Please refer to the "Services" tutorial for more details.
     */</span>
    <span class="k">using</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="p">;</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceServer</span><span class="o">&lt;</span><span class="n">BeginFirmwareUpdate</span><span class="o">&gt;</span> <span class="n">srv</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">srv_start_res</span> <span class="o">=</span> <span class="n">srv</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ReceivedDataStructure</span><span class="o">&lt;</span><span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Request</span><span class="o">&gt;&amp;</span> <span class="n">req</span><span class="p">,</span> <span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">rsp</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">req</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">rsp</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">rsp</span><span class="p">.</span><span class="n">ERROR_UNKNOWN</span><span class="p">;</span>
        <span class="n">rsp</span><span class="p">.</span><span class="n">optional_error_message</span> <span class="o">=</span> <span class="s">"I am filtered"</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">srv_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the server; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">srv_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/**
     * The method computeConfiguration() gathers information from all subscribers and service messages on the
     * configurator's node. Also it creates a container with automatically calculated configurations of Masks and
     * ID's and subsequently loads the configurations to the CAN controller.
     *
     * It may or may not take an argument:
     * - IgnoreAnonymousMessages
     * - AcceptAnonymousMessages (default, if no input arguments)
     *
     * By default filter configurator accepts all anonymous messages. If you don't want them, you may specify the
     * IgnoreAnonymousMessages input argument. Let's make configurator that accepts anonymous messages.
     */</span>
    <span class="n">anon_test_configuration</span><span class="p">.</span><span class="n">computeConfiguration</span><span class="p">();</span>

    <span class="cm">/**
     * At this point you have your configuration calculated and stored within the class container multiset_configs_, but
     * it's not still applied. Let's take a look what is inside the container of configurations using method
     * getConfiguration(). The output should consist of four configurations: service, anonymous, air_data::TrueAirspeed
     * and air_data::Sideslip messages.
     */</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">configure_array</span> <span class="o">=</span> <span class="n">anon_test_configuration</span><span class="p">.</span><span class="n">getConfiguration</span><span class="p">();</span>
    <span class="kt">uint16_t</span> <span class="n">configure_array_size</span> <span class="o">=</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Configuration with AcceptAnonymousMessages input and two subscribers:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">configure_array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.ID ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.MK ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="cm">/**
     * Our node keeps getting air_data::Sideslip messages since configureCanAcceptanceFilters() was called previously
     * and service message file::BeginFirmwareUpdate since the service was declared (always accepted by UAVCAN, again).
     * But the air_data::TrueAirspeed is still not being accepted, even though it's within the multiset_configs_
     * container. In order to carry out the configuration let's call applyConfiguration() in 3 seconds and start to
     * get another message.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">3000</span><span class="p">));</span> <span class="c1">// Wait 3 seconds
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Applying new configuration, air_data::TrueAirspeed is accepted now..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">anon_test_configuration</span><span class="p">.</span><span class="n">applyConfiguration</span><span class="p">();</span>

    <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">3000</span><span class="p">));</span> <span class="c1">// Wait 3 seconds
</span>    <span class="cm">/**
     * If there is a need of adding new custom configuration to hardware filters you may utilize
     * addFilterConfig(CanFilterConfig&amp; config) method. It must be called only after computeConfiguration() function is
     * called, otherwise you might lose your custom configurations. Every time computeConfiguration() is invoked, it
     * cleans the multiset_configs_ container.
     * Let's add 5 additional configurations:
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">CanFilterConfig</span> <span class="n">new_filter</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">new_filter</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
        <span class="n">new_filter</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">anon_test_configuration</span><span class="p">.</span><span class="n">addFilterConfig</span><span class="p">(</span><span class="n">new_filter</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Container after adding new custom configurations:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">configure_array_size</span> <span class="o">=</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">configure_array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.ID ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.MK ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * If the number of configurations within the container is higher than number of available filters (6 in this
     * tutorial), the excessive configurations will be merged in the most efficient way. The container has 10
     * configurations at the moment. Let's invoke applyConfiguration() method and display our container once again,
     * the number of configurations will be reduced to 6.
     */</span>
    <span class="n">anon_test_configuration</span><span class="p">.</span><span class="n">applyConfiguration</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Container after adding new custom configurations and applyConfiguration():"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">configure_array_size</span> <span class="o">=</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">configure_array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.ID ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"config.MK ["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]= "</span> <span class="o">&lt;&lt;</span> <span class="n">configure_array</span><span class="p">.</span><span class="n">getByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/*
         * The method spin() may return earlier if an error occurs (e.g. driver failure).
         * All error codes are listed in the header uavcan/error.hpp.
         */</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">getInfinite</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="running-on-linux">Running on Linux</h2>

<p>Build the applications using the following CMake script:</p>

<div class="language-cmake highlighter-rouge"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>tutorial_project<span class="p">)</span>

<span class="nb">find_library</span><span class="p">(</span>UAVCAN_LIB uavcan REQUIRED<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"-Wall -Wextra -pedantic -std=c++11"</span><span class="p">)</span>

<span class="c1"># Make sure to provide correct path to 'platform_linux.cpp'! See earlier tutorials for more info.</span>
<span class="nb">add_executable</span><span class="p">(</span>publisher_client publisher_client.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>publisher_client <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>subscriber_server subscriber_server.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>subscriber_server <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>
</code></pre>
</div>
