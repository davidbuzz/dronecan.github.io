<h1 id="firmware-update">Firmware update</h1>

<p>This advanced-level tutorial shows how to implement firmware update over UAVCAN using libuavcan.
The reader must be familiar with the corresponding section of the specification.
Two applications will be implemented:</p>

<ul>
  <li>Updater - this application runs an active node monitor (this topic has been covered in one of the previous tutorials),
and when a remote node responds to <code class="highlighter-rouge">uavcan.protocol.GetNodeInfo</code> request, the application checks if it has a newer
firmware image than the node is currently running. If this is the case, the application sends a request of type
<code class="highlighter-rouge">uavcan.protocol.file.BeginFirmwareUpdate</code> to the node. This application also implements a file server, which is
another mandatory component of the firmware update process.</li>
  <li>Updatee - this application demonstrates how to handle requests of type <code class="highlighter-rouge">uavcan.protocol.file.BeginFirmwareUpdate</code>,
and how to download a file using the service <code class="highlighter-rouge">uavcan.protocol.file.Read</code>.</li>
</ul>

<p>Launch instructions are provided after the source code below.</p>

<p>It is advised to refer to a real production-used cross-platform UAVCAN bootloader implemented by
<a href="http://px4.io">PX4 development team</a>.</p>

<h2 id="updater">Updater</h2>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cm">/*
 * Classes that implement high-level protocol logic
 */</span>
<span class="cp">#include &lt;uavcan/protocol/firmware_update_trigger.hpp&gt;  // uavcan::FirmwareUpdateTrigger
#include &lt;uavcan/protocol/node_info_retriever.hpp&gt;      // uavcan::NodeInfoRetriever (see tutorial "Node discovery")
</span>
<span class="cm">/*
 * We're using POSIX-dependent classes and POSIX API in this example.
 * This means that the example will only work as-is on a POSIX-compliant system (e.g. Linux, NuttX),
 * otherwise the said classes will have to be re-implemented.
 */</span>
<span class="cp">#include &lt;uavcan_posix/basic_file_server_backend.hpp&gt;
#include &lt;glob.h&gt;                                       // POSIX glob() function
</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="cm">/**
 * This class implements the application-specific part of uavcan::FirmwareUpdateTrigger
 * via the interface uavcan::IFirmwareVersionChecker.
 *
 * It works as follows: uavcan::FirmwareUpdateTrigger is subscribed to node information reports from
 * uavcan::NodeInfoRetriever via the interface uavcan::INodeInfoListener (learn more on node monitoring
 * in the tutorial "Node discovery"). Whenever FirmwareUpdateTrigger receives information about a new node,
 * it relays this information to the application via the interface uavcan::IFirmwareVersionChecker.
 * The application is then expected to check, using the information provided, whether the node requires
 * a firmware update, and reports the results of the check back to FirmwareUpdateTrigger. If the node requires
 * an update, FirmwareUpdateTrigger will send it a request uavcan.protocol.file.BeginFirmwareUpdate; otherwise
 * the node will be ignored until it restarts or re-appears on the bus. If the node did not respond to the update
 * request, FirmwareUpdateTrigger will try again. If the node responded with an error, FirmwareUpdateTrigger
 * will ask the application, using the same interface, whether it needs to try again.
 *
 * Refer to the source of uavcan::FirmwareUpdateTrigger to read more documentation.
 */</span>
<span class="k">class</span> <span class="nc">ExampleFirmwareVersionChecker</span> <span class="n">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">IFirmwareVersionChecker</span>
<span class="p">{</span>
    <span class="cm">/**
     * This method will be invoked when the class obtains a response to GetNodeInfo request.
     *
     * @param node_id                   Node ID that this GetNodeInfo response was received from.
     *
     * @param node_info                 Actual node info structure; refer to uavcan.protocol.GetNodeInfo for details.
     *
     * @param out_firmware_file_path    The implementation should return the firmware image path via this argument.
     *                                  Note that this path must be reachable via uavcan.protocol.file.Read service.
     *                                  Refer to @ref FileServer and @ref BasicFileServer for details.
     *
     * @return                          True - the class will begin sending update requests.
     *                                  False - the node will be ignored, no request will be sent.
     */</span>
    <span class="kt">bool</span> <span class="n">shouldRequestFirmwareUpdate</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">node_id</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">GetNodeInfo</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">node_info</span><span class="p">,</span>
                                     <span class="n">FirmwareFilePath</span><span class="o">&amp;</span> <span class="n">out_firmware_file_path</span><span class="p">)</span>
    <span class="n">override</span>
    <span class="p">{</span>
        <span class="cm">/*
         * We need to make the decision, given the inputs, whether the node requires an update.
         * This part of the logic is deeply application-specific, so the solution provided here may not work
         * for some real-world applications.
         *
         * It is recommended to refer to the PX4 autopilot project or to the APM project for a real-world
         * example.
         *
         * Both PX4 and APM leverage a class provided by the libuavcan's POSIX platform driver -
         * uavcan_posix::FirmwareVersionChecker - which implements a generic firmware version checking algorithm.
         * The algorithm works as follows:
         *   1. Check if the file system has a firmware file for the given node.
         *      If not, exit - update will not be possible anyway.
         *   2. Compare the CRC of the local firmware image for the given node with CRC of the firmware the node is
         *      running at the moment (the latter is available via the node info argument in this method).
         *   3. Request an update if CRC don't match, otherwise do not request an update.
         *
         * In this example, we're using a simpler logic.
         *
         * Firmware file name pattern used in the example is as follows:
         *      &lt;node-name&gt;-&lt;hw-major&gt;.&lt;hw-minor&gt;-&lt;sw-major&gt;.&lt;sw-minor&gt;.&lt;vcs-hash-hex&gt;.uavcan.bin
         */</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Checking firmware version of node "</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">node_id</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">"; node info:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">node_info</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="cm">/*
         * Looking for matching firmware files.
         */</span>
        <span class="k">auto</span> <span class="n">files</span> <span class="o">=</span> <span class="n">findAvailableFirmwareFiles</span><span class="p">(</span><span class="n">node_info</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"No firmware files found for this node"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Matching firmware files:"</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="n">files</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\t</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">parseFirmwareFileName</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">c_str</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Looking for the firmware file with highest version number
         */</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">best_file_name</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">best_combined_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="n">files</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">inf</span> <span class="o">=</span> <span class="n">parseFirmwareFileName</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
            <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">combined_version</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">inf</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">major</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">inf</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">minor</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">combined_version</span> <span class="o">&gt;=</span> <span class="n">best_combined_version</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">best_combined_version</span> <span class="o">=</span> <span class="n">combined_version</span><span class="p">;</span>
                <span class="n">best_file_name</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Preferred firmware: "</span> <span class="o">&lt;&lt;</span> <span class="n">best_file_name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">const</span> <span class="k">auto</span> <span class="n">best_firmware_info</span> <span class="o">=</span> <span class="n">parseFirmwareFileName</span><span class="p">(</span><span class="n">best_file_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

        <span class="cm">/*
         * Comparing the best firmware with the actual one, requesting an update if they differ.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">best_firmware_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">major</span> <span class="o">==</span> <span class="n">node_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">major</span> <span class="o">&amp;&amp;</span>
            <span class="n">best_firmware_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">minor</span> <span class="o">==</span> <span class="n">node_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">minor</span> <span class="o">&amp;&amp;</span>
            <span class="n">best_firmware_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">vcs_commit</span> <span class="o">==</span> <span class="n">node_info</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">vcs_commit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Firmware is already up-to-date"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * The current implementation of FirmwareUpdateTrigger imposes a limitation on the maximum length of
         * the firmware file path: it must not exceed 40 characters. This is NOT a limitation of UAVCAN itself.
         *
         * The firmware file name format we're currently using may procude names that exceed the length limitation,
         * therefore we need to work around that. We do so by means of computing a hash (CRC64 in this example, but
         * it obviously could be any other hash), and using it as the name of symlink to the firmware file.
         *
         * Aside from complying with the library's limitation, use of shorter lengths allows to somewhat reduce bus
         * traffic resulting from file read requests from the updatee, as every request carries the name of the file.
         *
         * TODO: Do not use symlink if file name length does not exceed the limit.
         */</span>
        <span class="n">out_firmware_file_path</span> <span class="o">=</span> <span class="n">makeFirmwareFileSymlinkName</span><span class="p">(</span><span class="n">best_file_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">best_file_name</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>

        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">out_firmware_file_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">symlink_res</span> <span class="o">=</span> <span class="o">::</span><span class="n">symlink</span><span class="p">(</span><span class="n">best_file_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">out_firmware_file_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">symlink_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Could not create symlink: "</span> <span class="o">&lt;&lt;</span> <span class="n">symlink_res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Firmware file symlink: "</span> <span class="o">&lt;&lt;</span> <span class="n">out_firmware_file_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * This method will be invoked when a node responds to the update request with an error. If the request simply
     * times out, this method will not be invoked.
     * Note that if by the time of arrival of the response the node is already removed, this method will not be called.
     *
     * SPECIAL CASE: If the node responds with ERROR_IN_PROGRESS, the class will assume that further requesting
     *               is not needed anymore. This method will not be invoked.
     *
     * @param node_id                   Node ID that returned this error.
     *
     * @param error_response            Contents of the error response. It contains error code and text.
     *
     * @param out_firmware_file_path    New firmware path if a retry is needed. Note that this argument will be
     *                                  initialized with old path, so if the same path needs to be reused, this
     *                                  argument should be left unchanged.
     *
     * @return                          True - the class will continue sending update requests with new firmware path.
     *                                  False - the node will be forgotten, new requests will not be sent.
     */</span>
    <span class="kt">bool</span> <span class="n">shouldRetryFirmwareUpdate</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">node_id</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">error_response</span><span class="p">,</span>
                                   <span class="n">FirmwareFilePath</span><span class="o">&amp;</span> <span class="n">out_firmware_file_path</span><span class="p">)</span>
    <span class="n">override</span>
    <span class="p">{</span>
        <span class="cm">/*
         * In this implementation we cancel the update request if the node responds with an error.
         */</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The node "</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">node_id</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">" has rejected the update request; file path was:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">out_firmware_file_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">response was:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">error_response</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * This node is invoked when the node responds to the update request with confirmation.
     * Note that if by the time of arrival of the response the node is already removed, this method will not be called.
     *
     * Implementation is optional; default one does nothing.
     *
     * @param node_id   Node ID that confirmed the request.
     *
     * @param response  Actual response.
     */</span>
    <span class="kt">void</span> <span class="n">handleFirmwareUpdateConfirmation</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">node_id</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span>
    <span class="n">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Node "</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">node_id</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">" has confirmed the update request; response was:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * This function is specific for this example implementation.
     * It computes the name of a symlink to the firmware file.
     * Please see explanation above, where the function is called from.
     * The implementation is made so that it can work even on a deeply embedded system.
     */</span>
    <span class="k">static</span> <span class="n">FirmwareFilePath</span> <span class="n">makeFirmwareFileSymlinkName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file_name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">file_name_length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">DataTypeSignatureCRC</span> <span class="n">hash</span><span class="p">;</span>
        <span class="n">hash</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">file_name</span><span class="p">),</span> <span class="n">file_name_length</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">hash_val</span> <span class="o">=</span> <span class="n">hash</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

        <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Charset</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"0123456789abcdefghijklmnopqrstuvwxyz"</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">CharsetSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Charset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">FirmwareFilePath</span> <span class="n">out</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">hash_val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">out</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Charset</span><span class="p">[</span><span class="n">hash_val</span> <span class="o">%</span> <span class="n">CharsetSize</span><span class="p">]);</span>
            <span class="n">hash_val</span> <span class="o">/=</span> <span class="n">CharsetSize</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="s">".bin"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * This function is specific for this example implementation.
     * It extracts the version information from firmware file name.
     * The implementation is made so that it can work even on a deeply embedded system.
     * Assumed format is:
     *      &lt;node-name&gt;-&lt;hw-major&gt;.&lt;hw-minor&gt;-&lt;sw-major&gt;.&lt;sw-minor&gt;.&lt;vcs-hash-hex&gt;.uavcan.bin
     */</span>
    <span class="k">static</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">GetNodeInfo</span><span class="o">::</span><span class="n">Response</span> <span class="n">parseFirmwareFileName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Must be static in order to avoid heap allocation
</span>        <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">extract_uint8</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isdigit</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span>
            <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="kt">int</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
                <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">GetNodeInfo</span><span class="o">::</span><span class="n">Response</span> <span class="n">res</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'-'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
            <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">res</span><span class="p">.</span><span class="n">hardware_version</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">extract_uint8</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">hardware_version</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">extract_uint8</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">extract_uint8</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">extract_uint8</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

        <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">vcs_commit</span> <span class="o">=</span> <span class="o">::</span><span class="n">strtoul</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">optional_field_flags</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">software_version</span><span class="p">.</span><span class="n">OPTIONAL_FIELD_FLAG_VCS_COMMIT</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * This function is specific for this example implementation.
     * It returns the firmware files available for given node info struct.
     */</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findAvailableFirmwareFiles</span><span class="p">(</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">GetNodeInfo</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">glob_matches</span><span class="p">;</span>

        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">glob_pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">())</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span>
                                         <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">hardware_version</span><span class="p">.</span><span class="n">major</span><span class="p">)</span> <span class="o">+</span> <span class="s">"."</span> <span class="o">+</span>
                                         <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">hardware_version</span><span class="p">.</span><span class="n">minor</span><span class="p">)</span> <span class="o">+</span> <span class="s">"-*.uavcan.bin"</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="o">::</span><span class="n">glob_t</span><span class="p">();</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">::</span><span class="n">glob</span><span class="p">(</span><span class="n">glob_pattern</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">::</span><span class="n">globfree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">GLOB_NOMATCH</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">glob_matches</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Can't glob()"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">gl_pathc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">glob_matches</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">gl_pathv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="o">::</span><span class="n">globfree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">glob_matches</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/*
     * Initializing the node.
     *
     * Typically, a node that serves as a firmware updater will also implement a dynamic node ID allocator.
     * Refer to the tutorial "Dynamic node ID allocation" to learn how to add a dynamic node ID allocator
     * to your node using libuavcan.
     *
     * Also keep in mind that in most real-world applications, features dependent on blocking APIs
     * (such as this firmware update feature) will have to be implemented in a secondary thread in order to not
     * interfere with real-time processing of the primary thread. In the case of this firmware updater, the
     * interference may be caused by relatively intensive processing and blocking calls to the file system API.
     * Please refer to the dedicated tutorial to learn how to implement a multi-threaded node, then use that
     * knowledge to make this example application multithreaded (consider this an excercise).
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="mi">16384</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.updater"</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing the node info retriever.
     *
     * We don't need it, but it will be used by the firmware version checker, which will be initialized next.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeInfoRetriever</span> <span class="n">node_info_retriever</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">retriever_res</span> <span class="o">=</span> <span class="n">node_info_retriever</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retriever_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node info retriever: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">retriever_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing the firmware update trigger.
     *
     * This class monitors the output of uavcan::NodeInfoRetriever, and using this output decides which nodes need
     * to update their firmware. When a node that requires an update is detected, the class sends a service request
     * uavcan.protocol.file.BeginFirmwareUpdate to it.
     *
     * The application-specific logic that performs the checks is implemented in the class
     * ExampleFirmwareVersionChecker, defined above in this file.
     */</span>
    <span class="n">ExampleFirmwareVersionChecker</span> <span class="n">checker</span><span class="p">;</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">FirmwareUpdateTrigger</span> <span class="n">trigger</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">checker</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">trigger_res</span> <span class="o">=</span> <span class="n">trigger</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">node_info_retriever</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trigger_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the firmware update trigger: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">trigger_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Initializing the file server.
     *
     * It is not necessary to run the file server on the same node with the firmware update trigger
     * (this is explained in the specification), but this use case is the most common, so we'll demonstrate it here.
     */</span>
    <span class="n">uavcan_posix</span><span class="o">::</span><span class="n">BasicFileServerBackend</span> <span class="n">file_server_backend</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">FileServer</span> <span class="n">file_server</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">file_server_backend</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">file_server_res</span> <span class="o">=</span> <span class="n">file_server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file_server_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the file server: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">file_server_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Started successfully"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="cm">/*
     * Running the node normally.
     * All of the work will be done in background.
     */</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">getInfinite</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="updatee">Updatee</h2>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;unistd.h&gt;
#include &lt;uavcan/uavcan.hpp&gt;
</span>
<span class="cm">/*
 * Data types used.
 */</span>
<span class="cp">#include &lt;uavcan/protocol/file/BeginFirmwareUpdate.hpp&gt;
#include &lt;uavcan/protocol/file/Read.hpp&gt;
</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ICanDriver</span><span class="o">&amp;</span> <span class="n">getCanDriver</span><span class="p">();</span>
<span class="k">extern</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ISystemClock</span><span class="o">&amp;</span> <span class="n">getSystemClock</span><span class="p">();</span>

<span class="cm">/**
 * This class downloads a firmware image from specified location to memory.
 * Download will start immediately after the object is constructed,
 * and it can be cancelled by means of deleting the object.
 *
 * This is just a made-up example - real applications will likely behave differently, either:
 * - Downloading the image using a dedicated bootloader application.
 * - Downloading the image to a file, that will be deployed later.
 * - Possibly something else, depending on the requirements of the application.
 */</span>
<span class="k">class</span> <span class="nc">FirmwareLoader</span> <span class="o">:</span> <span class="k">private</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerBase</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="cm">/**
     * State transitions:
     *  InProgress ---[after background work]----&gt; Success
     *                                       \ --&gt; Failure
     */</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span>
    <span class="p">{</span>
        <span class="n">InProgress</span><span class="p">,</span>
        <span class="n">Success</span><span class="p">,</span>
        <span class="n">Failure</span>
    <span class="p">};</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">source_node_id_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Path</span><span class="o">::</span><span class="n">FieldTypes</span><span class="o">::</span><span class="n">path</span> <span class="n">source_path_</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">image_</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">MethodBinder</span><span class="o">&lt;</span><span class="n">FirmwareLoader</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">void</span> <span class="p">(</span><span class="n">FirmwareLoader</span><span class="o">::*</span><span class="p">)(</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceCallResult</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Read</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span>
            <span class="n">ReadResponseCallback</span><span class="p">;</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceClient</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Read</span><span class="p">,</span> <span class="n">ReadResponseCallback</span><span class="o">&gt;</span> <span class="n">read_client_</span><span class="p">;</span>

    <span class="n">Status</span> <span class="n">status_</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">InProgress</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">handleTimerEvent</span><span class="p">(</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerEvent</span><span class="o">&amp;</span><span class="p">)</span> <span class="n">final</span> <span class="n">override</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_client_</span><span class="p">.</span><span class="n">hasPendingCalls</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Read</span><span class="o">::</span><span class="n">Request</span> <span class="n">req</span><span class="p">;</span>
            <span class="n">req</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">source_path_</span><span class="p">;</span>
            <span class="n">req</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">image_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">read_client_</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">source_node_id_</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Read call failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">handleReadResponse</span><span class="p">(</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceCallResult</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Read</span><span class="o">&gt;&amp;</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">isSuccessful</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
            <span class="n">result</span><span class="p">.</span><span class="n">getResponse</span><span class="p">().</span><span class="n">error</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">getResponse</span><span class="p">().</span><span class="n">data</span><span class="p">;</span>

            <span class="n">image_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">image_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">capacity</span><span class="p">())</span>  <span class="c1">// Termination condition
</span>            <span class="p">{</span>
                <span class="n">status_</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
                <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerBase</span><span class="o">::</span><span class="n">stop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">status_</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">Failure</span><span class="p">;</span>
            <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerBase</span><span class="o">::</span><span class="n">stop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="cm">/**
     * Download will start immediately upon construction.
     * Destroy the object to cancel the process.
     */</span>
    <span class="n">FirmwareLoader</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">INode</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span>
                   <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span> <span class="n">source_node_id</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">Path</span><span class="o">::</span><span class="n">FieldTypes</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">source_path</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerBase</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
        <span class="n">source_node_id_</span><span class="p">(</span><span class="n">source_node_id</span><span class="p">),</span>
        <span class="n">source_path_</span><span class="p">(</span><span class="n">source_path</span><span class="p">),</span>
        <span class="n">read_client_</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">image_</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>   <span class="c1">// Arbitrary value
</span>
        <span class="cm">/*
         * According to the specification, response priority equals request priority.
         * Typically, file I/O should be executed at a very low priority level.
         */</span>
        <span class="n">read_client_</span><span class="p">.</span><span class="n">setPriority</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">TransferPriority</span><span class="o">::</span><span class="n">OneHigherThanLowest</span><span class="p">);</span>
        <span class="n">read_client_</span><span class="p">.</span><span class="n">setCallback</span><span class="p">(</span><span class="n">ReadResponseCallback</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FirmwareLoader</span><span class="o">::</span><span class="n">handleReadResponse</span><span class="p">));</span>

        <span class="cm">/*
         * Rate-limiting is necessary to avoid bus congestion.
         * The exact rate depends on the application's requirements and CAN bit rate.
         */</span>
        <span class="n">uavcan</span><span class="o">::</span><span class="n">TimerBase</span><span class="o">::</span><span class="n">startPeriodic</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/**
     * This method allows to detect when the downloading is done, and whether it was successful.
     */</span>
    <span class="n">Status</span> <span class="n">getStatus</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">status_</span><span class="p">;</span> <span class="p">}</span>

    <span class="cm">/**
     * Returns the downloaded image.
     */</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">getImage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">image_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * This function is used to display the downloaded image.
 */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">printHexDump</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">RAIIFlagsSaver</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">fmtflags</span> <span class="n">flags_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flags</span><span class="p">();</span>
        <span class="o">~</span><span class="n">RAIIFlagsSaver</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flags</span><span class="p">(</span><span class="n">flags_</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span> <span class="n">_flags_saver</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">BytesPerRow</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="s">"  "</span><span class="p">;</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">BytesPerRow</span><span class="p">;</span>

        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BytesPerRow</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="kt">unsigned</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
                    <span class="o">++</span><span class="n">it</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"   "</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BytesPerRow</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">32U</span> <span class="o">&amp;&amp;</span> <span class="kt">unsigned</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">126U</span><span class="p">)</span> <span class="o">?</span> <span class="kt">char</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)</span> <span class="o">:</span> <span class="sc">'.'</span><span class="p">);</span>
                <span class="o">++</span><span class="n">begin</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usage: "</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" &lt;node-id&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">self_node_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/*
     * Initializing the node.
     * Hardware and software version information is paramount for firmware update process.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">Node</span><span class="o">&lt;</span><span class="mi">16384</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="n">getCanDriver</span><span class="p">(),</span> <span class="n">getSystemClock</span><span class="p">());</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setNodeID</span><span class="p">(</span><span class="n">self_node_id</span><span class="p">);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"org.uavcan.tutorial.updatee"</span><span class="p">);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">HardwareVersion</span> <span class="n">hwver</span><span class="p">;</span>    <span class="c1">// TODO initialize correct values
</span>    <span class="n">hwver</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setHardwareVersion</span><span class="p">(</span><span class="n">hwver</span><span class="p">);</span>

    <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">SoftwareVersion</span> <span class="n">swver</span><span class="p">;</span>    <span class="c1">// TODO initialize correct values
</span>    <span class="n">swver</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">node</span><span class="p">.</span><span class="n">setSoftwareVersion</span><span class="p">(</span><span class="n">swver</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">node_start_res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_start_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the node; error: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_start_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Storage for the firmware downloader object.
     * Can be replaced with a smart pointer instead.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">LazyConstructor</span><span class="o">&lt;</span><span class="n">FirmwareLoader</span><span class="o">&gt;</span> <span class="n">fw_loader</span><span class="p">;</span>

    <span class="cm">/*
     * Initializing the BeginFirmwareUpdate server.
     */</span>
    <span class="n">uavcan</span><span class="o">::</span><span class="n">ServiceServer</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="o">&gt;</span> <span class="n">bfu_server</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">bfu_res</span> <span class="o">=</span> <span class="n">bfu_server</span><span class="p">.</span><span class="n">start</span><span class="p">(</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">fw_loader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">]</span>
        <span class="p">(</span><span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ReceivedDataStructure</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Request</span><span class="o">&gt;&amp;</span> <span class="n">req</span><span class="p">,</span>
         <span class="n">uavcan</span><span class="o">::</span><span class="n">protocol</span><span class="o">::</span><span class="n">file</span><span class="o">::</span><span class="n">BeginFirmwareUpdate</span><span class="o">::</span><span class="n">Response</span> <span class="n">resp</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Firmware update request:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">req</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fw_loader</span><span class="p">.</span><span class="n">isConstructed</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">resp</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">resp</span><span class="p">.</span><span class="n">ERROR_IN_PROGRESS</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="k">auto</span> <span class="n">source_node_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">source_node_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">req</span><span class="p">.</span><span class="n">getSrcNodeID</span><span class="p">()</span> <span class="o">:</span> <span class="n">req</span><span class="p">.</span><span class="n">source_node_id</span><span class="p">;</span>

                <span class="n">fw_loader</span><span class="p">.</span><span class="n">construct</span><span class="o">&lt;</span><span class="n">uavcan</span><span class="o">::</span><span class="n">INode</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">NodeID</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">image_file_remote_path</span><span class="p">.</span><span class="n">path</span><span class="p">)</span><span class="o">&gt;</span>
                    <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">,</span> <span class="n">req</span><span class="p">.</span><span class="n">image_file_remote_path</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Response:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">resp</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">});</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bfu_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Failed to start the BeginFirmwareUpdate server: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">bfu_res</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Running the node normally.
     * All of the work will be done in background.
     */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fw_loader</span><span class="p">.</span><span class="n">isConstructed</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="p">.</span><span class="n">setModeSoftwareUpdate</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fw_loader</span><span class="o">-&gt;</span><span class="n">getStatus</span><span class="p">()</span> <span class="o">!=</span> <span class="n">FirmwareLoader</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">InProgress</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fw_loader</span><span class="o">-&gt;</span><span class="n">getStatus</span><span class="p">()</span> <span class="o">==</span> <span class="n">FirmwareLoader</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">image</span> <span class="o">=</span> <span class="n">fw_loader</span><span class="o">-&gt;</span><span class="n">getImage</span><span class="p">();</span>

                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Firmware download succeeded ["</span> <span class="o">&lt;&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" bytes]"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                    <span class="n">printHexDump</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">image</span><span class="p">));</span>

                    <span class="c1">// TODO: save the firmware image somewhere.
</span>                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Firmware download failed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

                    <span class="c1">// TODO: handle the error, e.g. retry download, send a log message, etc.
</span>                <span class="p">}</span>

                <span class="n">fw_loader</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="p">.</span><span class="n">setModeOperational</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">uavcan</span><span class="o">::</span><span class="n">MonotonicDuration</span><span class="o">::</span><span class="n">fromMSec</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Transient failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="running-on-linux">Running on Linux</h2>

<p>Build the applications using the following CMake script:</p>

<div class="language-cmake highlighter-rouge"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>tutorial_project<span class="p">)</span>

<span class="nb">find_library</span><span class="p">(</span>UAVCAN_LIB uavcan REQUIRED<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"-Wall -Wextra -pedantic -std=c++11"</span><span class="p">)</span>

<span class="c1"># Make sure to provide correct path to 'platform_linux.cpp'! See earlier tutorials for more info.</span>
<span class="nb">add_executable</span><span class="p">(</span>updater updater.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>updater <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>updatee updatee.cpp <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../2._Node_initialization_and_startup/platform_linux.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>updatee <span class="si">${</span><span class="nv">UAVCAN_LIB</span><span class="si">}</span> rt<span class="p">)</span>

</code></pre>
</div>

<p>If the applications are started as-is, nothing interesting would happen,
because updater needs firmware files in order to issue update requests;
otherwise it will be ignoring nodes with a comment like <code class="highlighter-rouge">No firmware files found for this node</code>.</p>

<p>In order to make something happen, create a file named <code class="highlighter-rouge">org.uavcan.tutorial.updatee-1.0-5.0.0.uavcan.bin</code>
(naming format is explained in the source code), fill it with some data and then start both nodes.</p>

<p>In this case, updater will request updatee to update its firmware, because the provided firmware file
is declared to have higher firmware version number than updatee reports.</p>

<p>While firmware is being loaded, updatee will set its operating mode to <code class="highlighter-rouge">SOFTWARE_UPDATE</code>,
as can be seen using UAVCAN monitor application for Linux
(refer to the Linux platform driver documentation to learn more about available applications):</p>

<p><a class="imagelink" href="/Implementations/Libuavcan/Tutorials/11._Firmware_update/monitor_software_update.png" data-lightbox="/Implementations/Libuavcan/Tutorials/11._Firmware_update/monitor_software_update.png" data-title="Sample">
<img src="/Implementations/Libuavcan/Tutorials/11._Firmware_update/monitor_software_update.png" class="" style="" />
</a></p>

<p>Possible output of updater:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./updater 1
Started successfully
Checking firmware version of node 2; node info:
status:
  uptime_sec: 0
  health: 0
  mode: 0
  sub_mode: 0
  vendor_specific_status_code: 0
software_version:
  major: 1
  minor: 0
  optional_field_flags: 0
  vcs_commit: 0
  image_crc: 0
hardware_version:
  major: 1
  minor: 0
  unique_id: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  certificate_of_authenticity: ""
name: "org.uavcan.tutorial.updatee"
Matching firmware files:
        org.uavcan.tutorial.updatee-1.0-5.0.0.uavcan.bin
status:
  uptime_sec: 0
  health: 0
  mode: 0
  sub_mode: 0
  vendor_specific_status_code: 0
software_version:
  major: 5
  minor: 0
  optional_field_flags: 1
  vcs_commit: 0
  image_crc: 0
hardware_version:
  major: 1
  minor: 0
  unique_id: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  certificate_of_authenticity: ""
name: "org.uavcan.tutorial.updatee"
Preferred firmware: org.uavcan.tutorial.updatee-1.0-5.0.0.uavcan.bin
Firmware file symlink: 93osmbx05mzk.bin
Node 2 has confirmed the update request; response was:
error: 0
optional_error_message: ""
</code></pre>
</div>

<p>Possible output of updatee:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./updatee 2
Firmware update request:
# Received struct ts_m=9534.001067 ts_utc=1443463579.015996 snid=1
source_node_id: 1
image_file_remote_path:
  path: "93osmbx05mzk.bin"
Response:
error: 0
optional_error_message: ""
Firmware download succeeded [881 bytes]
00000000  54 68 65 20 74 72 61 67  65 64 79 20 6f 66 20 68   The tragedy of h
00000010  75 6d 61 6e 20 6c 69 66  65 2c 20 69 74 20 69 73   uman life, it is
00000020  20 6f 66 74 65 6e 20 74  68 6f 75 67 68 74 2c 20    often thought,
00000030  69 73 20 74 68 61 74 20  6f 75 72 20 6d 6f 72 74   is that our mort
00000040  61 6c 69 74 79 20 6d 65  61 6e 73 20 74 68 61 74   ality means that
00000050  20 64 65 61 74 68 20 69  73 20 74 68 65 20 6f 6e    death is the on
00000060  6c 79 20 74 68 69 6e 67  20 74 68 61 74 20 77 65   ly thing that we
00000070  20 6b 6e 6f 77 0a 66 6f  72 20 73 75 72 65 20 61    know.for sure a
00000080  77 61 69 74 73 20 75 73  2e 20 54 68 65 20 73 74   waits us. The st
00000090  6f 72 79 20 6f 66 20 56  69 74 61 6c 69 61 20 74   ory of Vitalia t
000000a0  75 72 6e 73 20 74 68 69  73 20 63 6f 6e 76 65 6e   urns this conven
000000b0  74 69 6f 6e 61 6c 20 77  69 73 64 6f 6d 20 6f 6e   tional wisdom on
000000c0  20 69 74 73 20 68 65 61  64 20 61 6e 64 20 73 75    its head and su
000000d0  67 67 65 73 74 73 20 74  68 61 74 20 69 6d 6d 6f   ggests that immo
000000e0  72 74 61 6c 69 74 79 0a  77 6f 75 6c 64 20 62 65   rtality.would be
000000f0  20 61 20 63 75 72 73 65  2e 20 57 65 20 6e 65 65    a curse. We nee
00000100  64 20 64 65 61 74 68 20  74 6f 20 67 69 76 65 20   d death to give
00000110  73 68 61 70 65 20 61 6e  64 20 6d 65 61 6e 69 6e   shape and meanin
00000120  67 20 74 6f 20 6c 69 66  65 2e 20 57 69 74 68 6f   g to life. Witho
00000130  75 74 20 69 74 2c 20 77  65 20 77 6f 75 6c 64 20   ut it, we would
00000140  66 69 6e 64 20 6c 69 66  65 20 70 6f 69 6e 74 6c   find life pointl
00000150  65 73 73 2e 20 4f 6e 20  74 68 69 73 0a 76 69 65   ess. On this.vie
00000160  77 2c 20 69 66 20 68 65  6c 6c 20 69 73 20 65 74   w, if hell is et
00000170  65 72 6e 61 6c 20 64 61  6d 6e 61 74 69 6f 6e 2c   ernal damnation,
00000180  20 74 68 65 20 65 74 65  72 6e 69 74 79 20 6f 66    the eternity of
00000190  20 6c 69 66 65 20 69 6e  20 48 61 64 65 73 20 77    life in Hades w
000001a0  6f 75 6c 64 20 62 65 20  65 6e 6f 75 67 68 20 74   ould be enough t
000001b0  6f 20 6d 61 6b 65 20 69  74 20 61 20 70 6c 61 63   o make it a plac
000001c0  65 20 6f 66 20 70 75 6e  69 73 68 6d 65 6e 74 2e   e of punishment.
000001d0  0a 0a 49 74 20 69 73 20  73 75 72 70 72 69 73 69   ..It is surprisi
000001e0  6e 67 20 68 6f 77 20 66  65 77 20 70 65 6f 70 6c   ng how few peopl
000001f0  65 20 77 68 6f 20 74 68  69 6e 6b 20 65 74 65 72   e who think eter
00000200  6e 61 6c 20 6c 69 66 65  20 77 6f 75 6c 64 20 62   nal life would b
00000210  65 20 64 65 73 69 72 61  62 6c 65 20 74 68 69 6e   e desirable thin
00000220  6b 20 68 61 72 64 20 61  62 6f 75 74 20 77 68 61   k hard about wha
00000230  74 20 69 74 20 77 6f 75  6c 64 20 65 6e 74 61 69   t it would entai
00000240  6c 2e 20 54 68 61 74 0a  69 73 20 75 6e 64 65 72   l. That.is under
00000250  73 74 61 6e 64 61 62 6c  65 2e 20 57 68 61 74 20   standable. What
00000260  77 65 20 70 72 69 6d 61  72 69 6c 79 20 77 61 6e   we primarily wan
00000270  74 20 69 73 20 73 69 6d  70 6c 79 20 6d 6f 72 65   t is simply more
00000280  20 6c 69 66 65 2e 20 54  68 65 20 65 78 61 63 74    life. The exact
00000290  20 64 75 72 61 74 69 6f  6e 20 6f 66 20 74 68 65    duration of the
000002a0  20 65 78 74 72 61 20 6c  65 61 73 65 20 69 73 20    extra lease is
000002b0  6e 6f 74 20 6f 75 72 20  70 72 69 6d 65 0a 63 6f   not our prime.co
000002c0  6e 63 65 72 6e 2e 20 49  74 20 64 6f 65 73 20 73   ncern. It does s
000002d0  65 65 6d 20 74 68 61 74  20 73 65 76 65 6e 74 79   eem that seventy
000002e0  20 79 65 61 72 73 2c 20  69 66 20 77 65 e2 80 99    years, if we...
000002f0  72 65 20 6c 75 63 6b 79  2c 20 69 73 6e e2 80 99   re lucky, isn...
00000300  74 20 6c 6f 6e 67 20 65  6e 6f 75 67 68 2e 20 54   t long enough. T
00000310  68 65 72 65 20 61 72 65  20 73 6f 20 6d 61 6e 79   here are so many
00000320  20 70 6c 61 63 65 73 20  74 6f 20 73 65 65 2c 20    places to see,
00000330  73 6f 20 6d 75 63 68 0a  74 6f 20 64 6f 20 61 6e   so much.to do an
00000340  64 20 65 78 70 65 72 69  65 6e 63 65 2e 20 49 66   d experience. If
00000350  20 6f 6e 6c 79 20 77 65  20 68 61 64 20 6d 6f 72    only we had mor
00000360  65 20 74 69 6d 65 20 74  6f 20 64 6f 20 69 74 21   e time to do it!
00000370  0a                                                 .
</code></pre>
</div>
