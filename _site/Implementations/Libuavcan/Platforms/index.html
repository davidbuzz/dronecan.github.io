<h1 id="libuavcan-platforms">Libuavcan platforms</h1>

<p>In the context of Libuavcan, a <em>platform</em> is a particular hardware platform or an operating system that can
execute libuavcan-based UAVCAN nodes.
For example, the STM32 microcontroller family and the GNU/Linux OS are some of the officially supported
libuavcan platforms.</p>

<p>A <em>platform driver</em> is a set of platform-specific C++ classes that implement the thin layer of
glue logic needed to make libuavcan function with the particular platform at hand.</p>

<h2 id="adding-support-for-a-new-platform">Adding support for a new platform</h2>

<p>Implementing a platform driver for libuavcan is generally a quite straightforward task,
especially if the driver is targeted for a certain application and need not to be generic.</p>

<p>Essentially, a libuavcan driver is a set of C++ classes implementing the following C++ interfaces:</p>

<ul>
  <li><code class="highlighter-rouge">uavcan::ICanDriver</code></li>
  <li><code class="highlighter-rouge">uavcan::ICanIface</code></li>
  <li><code class="highlighter-rouge">uavcan::ISystemClock</code></li>
</ul>

<p>The interfaces listed above are defined in
<a href="https://github.com/UAVCAN/libuavcan/blob/master/libuavcan/include/uavcan/driver"><code class="highlighter-rouge">libuavcan/include/uavcan/driver/</code></a>.</p>

<p>Note that the library core already includes a non-blocking prioritized TX queue, so normally a driver should not
implement a software TX queue itself.</p>

<p>If the driver does not need to support redundant CAN bus interfaces,
then the first two C++ interfaces can be implemented in the same C++ class.</p>

<p>Some features can be left unimplemented:</p>

<ul>
  <li><strong>IO flags</strong> - needed for dynamic node ID allocation and time synchronization master.</li>
  <li><strong>TX timestamping</strong> - needed for clock synchronization master.</li>
  <li><strong>Hardware CAN filters configuration</strong> -
not necessary if there is enough computational power to delegate filtering to the library software.</li>
</ul>

<p>There are two extreme examples of the driver complexity level that can give a basic idea of the development effort required:</p>

<ul>
  <li>LPC11C24 driver - only necessary functionality, no redundant interface support, no TX timestamping - 600 LoC.</li>
  <li>Linux driver - complete full-featured driver with hardware timestamping and redundant interfaces - 1200 LoC.</li>
</ul>

<p>Contributions adding support for new platforms are always welcome.</p>

<h2 id="officially-supported-platforms">Officially supported platforms</h2>

<p>Official platform drivers are located in dedicated repositories here:
<a href="https://github.com/UAVCAN">github.com/UAVCAN</a>.
Contributions adding support for new platforms are always welcome.</p>

<p>Please refer to the platform driver source repositories for relevant documentation:</p>

<ul>
  <li><a href="https://github.com/UAVCAN/libuavcan_stm32">STM32</a></li>
  <li><a href="https://github.com/UAVCAN/libuavcan_linux">GNU/Linux</a></li>
  <li><a href="https://github.com/UAVCAN/libuavcan_lpc11c24">NXP LPC11C24</a></li>
</ul>

<h2 id="posix-helpers">POSIX helpers</h2>

<p>This is not a complete driver,
but rather a set of C++ classes that implement certain libuavcan interfaces in a cross-platform way,
so that they can be used on any POSIX-compliant operating system,
e.g. Linux or NuttX.
The libuavcan tutorials available in an adjacent section cover how to use these classes among other things.</p>

<p>The driver is implemented as a header-only C++ library.
The sources can be found in the main libuavcan source repository.</p>

<p>At least the following classes are implemented in the POSIX driver:</p>

<ul>
  <li>Firmware version checker - implements a simple firmware version checking strategy for firmware update servers.</li>
  <li>File server backend - implements file system I/O for UAVCAN file management services.</li>
  <li>File system backends for dynamic node ID allocation servers.</li>
</ul>
