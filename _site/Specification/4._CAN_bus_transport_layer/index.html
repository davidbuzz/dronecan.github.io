<h1 id="can-bus-transport-layer">CAN bus transport layer</h1>

<p>This chapter defines the CAN bus based transport layer of DroneCAN.</p>

<h2 id="the-concept-of-transfer">The concept of transfer</h2>

<p>A <em>Transfer</em> is an act of data transmission between nodes.
A transfer that is addressed to all nodes except the source node is a <em>broadcast transfer</em>.
A transfer that is addressed to one particular node is a <em>unicast transfer</em>.
DroneCAN defines the following types of transfers:</p>

<ul>
  <li>Message transfer - a broadcast transfer that contains a serialized message.</li>
  <li>Service transfer - a unicast transfer that contains either a service request or a service response.</li>
</ul>

<p>Both message and service transfers can be further distinguished between:</p>

<ul>
  <li>Single-frame transfer - a transfer that is entirely contained in a single CAN frame.</li>
  <li>Multi-frame transfer - a transfer that has its payload distributed over multiple CAN frames.</li>
</ul>

<p>The following properties are common to all types of transfer:</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Payload</td>
      <td>The serialized data structure</td>
    </tr>
    <tr>
      <td>Data type ID</td>
      <td>An identifier that indicates how the data structure should be interpreted</td>
    </tr>
    <tr>
      <td>Priority</td>
      <td>A positive integer value that defines the message urgency (0 is the highest priority). Higher priority transfers can delay transmission of lower priority transfers.</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>An integer value that allows receiving nodes to distinguish this transfer from all others</td>
    </tr>
  </tbody>
</table>

<h3 id="message-broadcasting">Message broadcasting</h3>

<p>A broadcast message is carried by a single message transfer that contains the serialized message.
A broadcast message has the following properties:</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Payload</td>
      <td>The serialized message</td>
    </tr>
    <tr>
      <td>Data type ID</td>
      <td>An identifier that indicates how the message should be interpreted</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>Node ID of the node that has transmitted the transfer</td>
    </tr>
    <tr>
      <td>Priority</td>
      <td>See above</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>See above</td>
    </tr>
  </tbody>
</table>

<p>In order to broadcast a message, the broadcasting node must have a node ID that is unique within the network.
An exception is applied to <em>anonymous message broadcasts</em>.</p>

<h4 id="anonymous-message-broadcasting">Anonymous message broadcasting</h4>

<p>An anonymous message is a transfer that originates from a node that does not have a node ID.
This sort of message transfer is useful for <em>dynamic node ID allocation</em> (a high-level concept that
will be explained in <a href="/Specification/6._Application_level_functions/">the chapter 6 of the specification</a>).</p>

<p>A node that does not have a node ID is said to be in <em>passive mode</em>.</p>

<p>An anonymous message has the same properties as a regular message, except for source node ID.</p>

<p>An anonymous transfer can only be a single-frame transfer. Multi-frame anonymous messages are not allowed.</p>

<p>Note that anonymous messages require specific arbitration rules and have restrictions on the acceptable
data type ID values.
The details are explained in the following chapters.</p>

<h4 id="timing">Timing</h4>

<p>Message transmission should be aborted if it cannot be completed in 1 second.</p>

<h3 id="service-invocation">Service invocation</h3>

<p>A service invocation consists of two service transfers:</p>

<ol>
  <li><em>Service request transfer</em> - from the node that invokes the service, known as <em>client</em>, to the node that provides
the service, known as <em>server</em>.</li>
  <li><em>Service response transfer</em> - once the server node receives the service request and processes it, it sends a
response transfer back to the client.</li>
</ol>

<p>A <em>service request transfer</em> has the following properties:</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Payload</td>
      <td>The serialized request structure</td>
    </tr>
    <tr>
      <td>Data type ID</td>
      <td>An identifier that indicates how the request should be interpreted</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>Node ID of the client</td>
    </tr>
    <tr>
      <td>Destination node ID</td>
      <td>Node ID of the server</td>
    </tr>
    <tr>
      <td>Priority</td>
      <td>See above</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>An integer value that: <br />1. allows the server to distinguish this request from other requests from the same client<br />2. allows the client to match the response with its request</td>
    </tr>
  </tbody>
</table>

<p>A <em>service response transfer</em> has the following properties:</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Payload</td>
      <td>The serialized response structure</td>
    </tr>
    <tr>
      <td>Data type ID</td>
      <td>Must be the same value as in the request transfer</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>Node ID of the server</td>
    </tr>
    <tr>
      <td>Destination node ID</td>
      <td>Node ID of the client</td>
    </tr>
    <tr>
      <td>Priority</td>
      <td>Should be the same value as in the request transfer</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>Must be the same value as in the request transfer</td>
    </tr>
  </tbody>
</table>

<p>Both client and server must have node ID values that are unique within the network.</p>

<h4 id="timing-1">Timing</h4>

<p>The following timings should be used, unless the application strongly requires different values:</p>

<ul>
  <li>Service transfer transmission should be aborted if does not complete in 1 second.</li>
  <li>The client should stop waiting for a response from the server if one has not arrived within 1 second.</li>
  <li>The server should be able to process any request in under 0.5 seconds.</li>
</ul>

<p>If different values are used, they must be explicitly documented.</p>

<h2 id="transmission">Transmission</h2>

<h3 id="transfer-id-computation">Transfer ID computation</h3>

<p>The <em>Transfer ID</em> is a small unsigned integer value that is added to every outgoing transfer
(it is used by receiving nodes to distinguish between individual transfers).</p>

<p>For <em>message transfers</em> and <em>service request transfers</em> the ID value should be computed as described below.
For <em>service response transfers</em> this value must be directly copied from the corresponding service request
transfer.</p>

<p>The logic to compute the <em>Transfer ID</em> relies on the concept of <em>transfer descriptor</em>.
A transfer descriptor is a set of properties that identify a particular set of transfers that originate from
the same node, share the same data type ID and the same type.
The properties that constitute a transfer descriptor are listed below:</p>

<ul>
  <li>Transfer type (message broadcast, service request, etc.)</li>
  <li>Data type ID</li>
  <li>Source node ID</li>
  <li>Destination node ID (only for unicast transfers)</li>
</ul>

<p>Every node that needs to publish a transfer must maintain the mapping from transfer descriptors to transfer ID.
This mapping is referred to as the <em>transfer ID map</em>.</p>

<p>Whenever a node needs to emit a transfer, it will query its transfer ID map for the appropriate transfer descriptor.
If the map does not contain such entry, a new entry will be created with transfer ID initialized to zero.
The node will use the current value of transfer ID from the map for the transfer, and then the value stored in the map
will be incremented by one.
When the stored transfer ID exceeds its maximum value, it will roll over to zero.</p>

<p>It is expected that some nodes will need to publish certain transfers aperiodically or on an ad-hoc basis, thereby creating
unused entries in the transfer ID map.
In order to avoid keeping unused entries in the map, the nodes are allowed, but not required,
to remove entries from the map that were not used for at least 2 seconds.
Therefore, it is possible that a node may publish a transfer with an out-of-order transfer ID value, if previous
transfer of the same descriptor has been published more than 2 seconds previously.</p>

<h3 id="payload-decomposition">Payload decomposition</h3>

<h4 id="single-frame-transfer">Single frame transfer</h4>

<p>If the size of the entire transfer payload does not exceed the space available for payload in a single CAN frame,
the whole transfer will be contained in one CAN frame. Such transfer is called a <em>single-frame transfer</em>.</p>

<p>Single frame transfers are more efficient than multi-frame transfers in terms of throughput and latency,
therefore it is advised to avoid the latter where possible.</p>

<h4 id="multi-frame-transfer">Multi-frame transfer</h4>

<p><em>Multi-frame transfers</em> are used when the size of the transfer payload exceeds the space available for payload in a
single CAN frame.</p>

<p>Two new concepts are introduced in the context of multi-frame transfers, both of which are reviewed below in detail:</p>

<ul>
  <li>Transfer CRC</li>
  <li>Toggle bit</li>
</ul>

<p>In order to make a multi-frame transfer, the node must first compute a CRC for the transfer payload.
The node prepends the CRC value to the transfer payload, and emits this data in chunks as a sequence of CAN frames (i.e. the first CAN frame contains the CRC and the first bytes of the payload).
The data field of all CAN frames of a multi-frame transfer, except the last one, must be filled/fully utilized.</p>

<p>All frames of a multi-frame transfer should be pushed to the bus at once, in the proper order from the first
frame to the last frame.</p>

<h5 id="transfer-crc">Transfer CRC</h5>

<p>The <em>Transfer CRC</em> is computed from the transfer payload, prepended with a data type signature, in little-endian byte order.
The diagram below illustrates the input of the transfer CRC function:</p>

<p><a class="imagelink" href="/Specification/figures/transfer_crc_input.png" data-lightbox="/Specification/figures/transfer_crc_input.png" data-title="Transfer CRC input">
<img src="/Specification/figures/transfer_crc_input.png" class="" style="" />
</a></p>

<p>The transfer CRC algorithm is specified as follows:</p>

<ul>
  <li>Name: CRC-16-CCITT-FALSE</li>
  <li>Description: <a href="http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat.crc-16-ccitt-false">http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat.crc-16-ccitt-false</a></li>
  <li>Initial value: 0xFFFF</li>
  <li>Poly: 0x1021</li>
  <li>Reverse: no</li>
  <li>Output XOR: 0</li>
  <li>Check: 0x29B1</li>
</ul>

<p>The following code provides an implementation of the transfer CRC algorithm in C++:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
 * License: CC0, no copyright reserved.
 */</span>

<span class="cp">#include &lt;iostream&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;
</span>
<span class="k">class</span> <span class="nc">TransferCRC</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">value_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">TransferCRC</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="mh">0xFFFFU</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">value_</span> <span class="o">^=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">bit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value_</span> <span class="o">&amp;</span> <span class="mh">0x8000U</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">value_</span> <span class="o">=</span> <span class="p">(</span><span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x1021U</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">value_</span> <span class="o">=</span> <span class="p">(</span><span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">++</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">TransferCRC</span> <span class="n">crc</span><span class="p">;</span>
    <span class="n">crc</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">"123456789"</span><span class="p">),</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="s">"0x"</span> <span class="o">&lt;&lt;</span> <span class="n">crc</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h5 id="toggle-bit">Toggle bit</h5>

<p>The <em>Toggle bit</em> is a property defined at the CAN frame level.
Its purpose is to detect and avoid CAN frame duplication errors.</p>

<p>The toggle bit of the first CAN frame of a multi-frame transfer must be set to zero.
The toggle bits of the following CAN frames of the transfer must alternate,
i.e. the toggle bit of the second CAN frame will be one, the toggle bit of the third CAN frame will be zero,
and so on.</p>

<h3 id="redundant-interface-support">Redundant interface support</h3>

<p>In configurations with redundant CAN bus interfaces, nodes are required to transmit every outgoing transfer via
all available redundant interfaces simultaneously.</p>

<p>An exception to the above rule is applicable if the payload of the transfer depends on some properties of the
interface through which the transfer is emitted.
An example of such a special case is the time-synchronization algorithm leveraged by DroneCAN
(documented in <a href="/Specification/6._Application_level_functions/">the chapter 6 of the specification</a>).</p>

<h2 id="can-frame-format">CAN frame format</h2>

<p>DroneCAN uses only CAN 2.0B frame format (29-bit identifiers).
DroneCAN can share the same bus with other protocols based on CAN 2.0A (11-bit identifiers).</p>

<h3 id="id-field">ID field</h3>

<p><a class="imagelink" href="/Specification/figures/can_id_format.png" data-lightbox="/Specification/figures/can_id_format.png" data-title="CAN ID format">
<img src="/Specification/figures/can_id_format.png" class="" style="" />
</a></p>

<p>Contents of the CAN ID field depend on the transfer type.</p>

<p>In the case of a message broadcast transfer, the CAN ID field of every frame of the transfer will contain
the following fields:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Bits</th>
      <th>Allowed values</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Priority</td>
      <td>5</td>
      <td>Any</td>
      <td> </td>
    </tr>
    <tr>
      <td>Message type ID</td>
      <td>16</td>
      <td>Any</td>
      <td>Data type ID of the encoded message</td>
    </tr>
    <tr>
      <td>Service not message</td>
      <td>1</td>
      <td>0</td>
      <td>Always zero</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>7</td>
      <td>1…127</td>
      <td>See below</td>
    </tr>
  </tbody>
</table>

<p>In the case of an anonymous message transfer, the CAN ID will contain the following fields:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Bits</th>
      <th>Allowed values</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Priority</td>
      <td>5</td>
      <td>Any</td>
      <td> </td>
    </tr>
    <tr>
      <td>Discriminator</td>
      <td>14</td>
      <td>Any</td>
      <td>See below</td>
    </tr>
    <tr>
      <td>Lower bits of message type ID</td>
      <td>2</td>
      <td>Any</td>
      <td>Data type ID of the encoded message</td>
    </tr>
    <tr>
      <td>Service not message</td>
      <td>1</td>
      <td>0</td>
      <td>Always zero</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>7</td>
      <td>0</td>
      <td>Always zero</td>
    </tr>
  </tbody>
</table>

<p>In the case of a service transfer, the CAN ID field of every frame of the transfer will contain the following fields:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Bits</th>
      <th>Allowed values</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Priority</td>
      <td>5</td>
      <td>Any</td>
      <td> </td>
    </tr>
    <tr>
      <td>Service type ID</td>
      <td>8</td>
      <td>Any</td>
      <td>Data type ID of the encoded service request or response</td>
    </tr>
    <tr>
      <td>Request not response</td>
      <td>1</td>
      <td>Any</td>
      <td>Values: 1 - service request transfer, 0 - service response transfer</td>
    </tr>
    <tr>
      <td>Destination node ID</td>
      <td>7</td>
      <td>1…127</td>
      <td>See below</td>
    </tr>
    <tr>
      <td>Service not message</td>
      <td>1</td>
      <td>1</td>
      <td>Always one</td>
    </tr>
    <tr>
      <td>Source node ID</td>
      <td>7</td>
      <td>1…127</td>
      <td>See below</td>
    </tr>
  </tbody>
</table>

<h4 id="priority">Priority</h4>

<p>Valid values for priority range from 0 to 31, inclusively, where 0 corresponds to highest priority (and 31 corresponds to lowest priority).</p>

<p>In multi-frame transfers, the value of the <em>priority</em> field must be identical for all frames of the transfer.</p>

<h4 id="message-type-id">Message type ID</h4>

<p>Valid values of message type ID range from 0 to 65535, inclusively.</p>

<p>Valid values of message type ID range for <em>anonymous message transfers</em> range from 0 to 3, inclusively.
This limitation is due to the fact that only 2 lower bits of the message type ID are available in this case.</p>

<h4 id="service-type-id">Service type ID</h4>

<p>Valid values of service type ID range from 0 to 255, inclusively.</p>

<h4 id="node-id">Node ID</h4>

<p>Valid values of Node ID range from 1 to 127, inclusively.</p>

<p>Note that Node ID is represented by a 7-bit unsigned integer value and that zero is reserved,
to represent either an unknown node or all nodes, depending on the context.</p>

<h4 id="discriminator">Discriminator</h4>

<p>CAN bus does not allow different nodes to transmit CAN frames with different data field values under the same CAN ID.
Owing to the fact that the CAN ID field includes the node ID value of the transmitting node,
this restriction is met by regular DroneCAN transfers.
However, anonymous message transfers violate this restriction, because they all share the same node ID of zero.</p>

<p>In order to work-around this problem, DroneCAN adds a discriminator to the CAN ID field of anonymous message
transfers, and defines special logic for handling CAN bus errors during transmission of anonymous frames.</p>

<p>The discriminator field must be filled with random data whenever a node transmits an anonymous message transfer.
The source of the random data must be likely to produce different discriminator values for different data field values.
A possible way of initializing the discriminator value is to apply the transfer CRC function (as defined above)
to the contents of the anonymous message, and then use any 14 bits of the result.
Nodes that adopt this approach will be using the same discriminator value for identical messages,
which is acceptable since this will not trigger an error on the bus.</p>

<p>Since the discriminator is only 14 bits long, the probability of having multiple nodes that are emitting CAN frames
with the same CAN ID but different data is higher than 0.006% (which is significant).
Therefore, the protocol must account for possible errors on the CAN bus triggered by CAN ID collisions.
In order to comply with this requirement,
DroneCAN requires all nodes to immediately abort transmission of all anonymous transfers once an error on the CAN bus is
detected.
This measure allows to prevent the bus deadlock that may occur if the automatic retransmission on bus error
is not suppressed.</p>

<h3 id="payload">Payload</h3>

<p><a class="imagelink" href="/Specification/figures/can_payload_format.png" data-lightbox="/Specification/figures/can_payload_format.png" data-title="CAN payload format">
<img src="/Specification/figures/can_payload_format.png" class="" style="" />
</a></p>

<p>The Data field of the CAN frame is shared between the following fields:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Transfer payload</td>
      <td>Actual payload of the transfer</td>
    </tr>
    <tr>
      <td>Tail byte</td>
      <td>The last byte of the CAN frame data field, which contains auxiliary transport layer fields</td>
    </tr>
  </tbody>
</table>

<p>The tail byte contains the following fields, starting from the most significant bit:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Bits</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Start of transfer</td>
      <td>1</td>
      <td>See below</td>
    </tr>
    <tr>
      <td>End of transfer</td>
      <td>1</td>
      <td>See below</td>
    </tr>
    <tr>
      <td>Toggle bit</td>
      <td>1</td>
      <td>See below</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>5</td>
      <td>The transfer ID value</td>
    </tr>
  </tbody>
</table>

<p>The following figure summarizes the data field format for a single-frame transfer:</p>

<p><a class="imagelink" href="/Specification/figures/single_frame_transfer.png" data-lightbox="/Specification/figures/single_frame_transfer.png" data-title="Single frame transfer">
<img src="/Specification/figures/single_frame_transfer.png" class="" style="" />
</a></p>

<p>The following figure summarizes the data field format for a multi-frame transfer:</p>

<p><a class="imagelink" href="/Specification/figures/multi_frame_transfer.png" data-lightbox="/Specification/figures/multi_frame_transfer.png" data-title="Multi frame transfer">
<img src="/Specification/figures/multi_frame_transfer.png" class="" style="" />
</a></p>

<h4 id="start-of-transfer">Start of transfer</h4>

<p>For single-frame transfers, the value of this field is always 1.</p>

<p>For multi-frame transfers, the value of this field is 1 if the current frame is the first frame of the transfer,
and 0 otherwise.</p>

<h4 id="end-of-transfer">End of transfer</h4>

<p>For single-frame transfers, the value of this field is always 1.</p>

<p>For multi-frame transfers, the value of this field is 1 if the current frame is the last frame of the transfer,
and 0 otherwise.</p>

<h4 id="toggle-bit-1">Toggle bit</h4>

<p>For single-frame transfers, the value of this field is always 0.</p>

<p>For multi-frame transfers, this field contains the value of the toggle bit.
As specified above this will alternate value between frames, starting at 0 for the first frame.</p>

<h4 id="transfer-id">Transfer ID</h4>

<p>This field contains the transfer ID value of the current transfer (for all types of transfers).</p>

<p>The value is 5 bits wide, therefore the allowed values range from 0 to 31, inclusively.</p>

<h2 id="reception">Reception</h2>

<h3 id="transfer-id-comparison">Transfer ID comparison</h3>

<p>The following explanation relies on the concept of <em>transfer ID forward distance</em>.
Transfer ID forward distance is a function of two transfer ID values, A and B,
that defines the number of increment operations that need to be applied to A so that A’ equals B.
Consider an example:</p>

<ul>
  <li>A = 0, B = 0 ⇒ forward distance 0</li>
  <li>A = 0, B = 5 ⇒ forward distance 5</li>
  <li>A = 31, B = 30 ⇒ forward distance 31 (overflow)</li>
  <li>A = 31, B = 0 ⇒ forward distance 1 (overflow)</li>
</ul>

<p>The following code sample provides an implementation of the transfer ID comparison algorithm in C++:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
 * License: CC0, no copyright reserved.
 */</span>

<span class="cp">#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;
</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">TransferIDBitLength</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">MaxValue</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">TransferIDBitLength</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1U</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">MaxValue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">MaxValue</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">TransferIDBitLength</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">assert</span><span class="p">((</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="n">MaxValue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">MaxValue</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(((</span><span class="n">a</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MaxValue</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span>  <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">1</span>  <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">7</span>  <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span>  <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">31</span> <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">));</span> <span class="c1">// overflow
</span>    <span class="n">assert</span><span class="p">(</span><span class="mi">1</span>  <span class="o">==</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>  <span class="c1">// overflow
</span><span class="p">}</span>
</code></pre>
</div>

<p><em>Half range</em> of transfer ID is 16.</p>

<h3 id="state-variables">State variables</h3>

<p>A node that can receive a transfer must keep a certain set of state variables for each transfer descriptor.
The set of state variables will be referred to as <em>receiver state</em>.
For the purposes of specification, it is assumed that the node will maintain a mapping from
transfer descriptors to receiver states, which is referred to as the <em>receiver map</em>.</p>

<p>The receiver state should include at least the following variables:</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Transfer payload</td>
      <td>Actual payload of the transfer</td>
    </tr>
    <tr>
      <td>Transfer ID</td>
      <td>Transfer ID value</td>
    </tr>
    <tr>
      <td>Next toggle bit</td>
      <td>Expected value of the toggle bit in the next frame of the transfer</td>
    </tr>
    <tr>
      <td>Transfer timestamp</td>
      <td>The local time when the first frame of the transfer arrived</td>
    </tr>
    <tr>
      <td>Interface index</td>
      <td>Only applicable for a redundant interface configuration</td>
    </tr>
  </tbody>
</table>

<p>The following operations are defined for the receiver state:</p>

<ul>
  <li>Add data to the payload - this operation adds new data to the current transfer’s payload state.</li>
  <li>Reinitialize - this operation resets the state variables to match the parameters of a new transfer.
Reinitialization includes at least the following:
    <ul>
      <li>Clearing the transfer payload;</li>
      <li>Updating the transfer ID value with the actual value from the new transfer;</li>
      <li>Clearing the toggle bit;</li>
      <li>Initializing the transfer timestamp;</li>
      <li>Initializing the interface index, if applicable.</li>
    </ul>
  </li>
</ul>

<p>The following conditions are defined for the receiver state:</p>

<ul>
  <li><em>Uninitialized</em> - this is a default condition, which indicates that the receiver has not yet seen any transfers.</li>
  <li><em>Transfer ID timeout</em> - last matching transfer was seen more than 2 seconds ago.</li>
  <li><em>Interface switch allowed</em> - this condition is only applicable for configurations with redundant CAN bus interfaces.
It means that the node is allowed to receive the next transfer from an interface that is not the same as the one the
previous transfer was received from. The condition will be reached if the last matching transfer has been successfully
received more than <em>T<sub>switch</sub></em> seconds ago. The value of <em>T<sub>switch</sub></em> must not exceed 2 seconds.
The actual value of <em>T<sub>switch</sub></em> can be either a constant chosen by the designer according to the application
requirements (e.g., maximum recovery time in an event of an interface failure), or the protocol stack
may estimate the value automatically by means of analysing the transfer intervals.</li>
</ul>

<p>Whenever a node receives a transfer, it will query its receiver map for the matching transfer descriptor.
If the matching state does not exist, the node will add a new uninitialized receiver state to the map.
The node then will proceed with the procedure of <em>receiver state update</em>, which is defined below.</p>

<p>It is expected that some transfers will be aperiodic or ad-hoc, which implies that the receiver map may accumulate
receiver states that are no longer used over time. Therefore, nodes are allowed, but not required, to remove any
receiver state from the receiver map, once the state reaches the transfer ID timeout condition.</p>

<p>Receiver state can only be modified when a new CAN frame of a matching transfer is received.
This guarantee simplifies implementation, as it implies that the receiver states will not require any background
maintenance processes.</p>

<h3 id="state-update-in-a-redundant-interface-configuration">State update in a redundant interface configuration</h3>

<p>The following pseudocode demonstrates the transfer reception process for
a configuration with redundant CAN bus interfaces.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Constants:
</span><span class="n">tid_timeout</span> <span class="o">:=</span> <span class="mi">2</span> <span class="n">seconds</span><span class="p">;</span>
<span class="n">tid_half_range</span> <span class="o">:=</span> <span class="mi">16</span><span class="p">;</span>
<span class="n">iface_switch_delay</span> <span class="o">:=</span> <span class="n">UserDefinedConstant</span><span class="p">;</span> <span class="c1">// Or autodetect
</span>
<span class="c1">// State variables:
</span><span class="n">initialized</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">payload</span><span class="p">;</span>
<span class="n">this_transfer_timestamp</span><span class="p">;</span>
<span class="n">current_transfer_id</span><span class="p">;</span>
<span class="n">iface_index</span><span class="p">;</span>
<span class="n">toggle</span><span class="p">;</span>

<span class="n">function</span> <span class="nf">receiveFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resolving the state flags:
</span>    <span class="n">tid_timed_out</span> <span class="o">:=</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">this_transfer_timestamp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tid_timeout</span><span class="p">;</span>
    <span class="n">same_iface</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">iface_index</span> <span class="o">==</span> <span class="n">iface_index</span><span class="p">;</span>
    <span class="n">first_frame</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">start_of_transfer</span><span class="p">;</span>
    <span class="n">non_wrapped_tid</span> <span class="o">:=</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="n">current_transfer_id</span><span class="p">,</span> <span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tid_half_range</span><span class="p">;</span>
    <span class="n">not_previous_tid</span> <span class="o">:=</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span><span class="p">,</span> <span class="n">current_transfer_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">iface_switch_allowed</span> <span class="o">:=</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">this_transfer_timestamp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">iface_switch_delay</span><span class="p">;</span>

    <span class="c1">// Using the state flags from above, deciding whether we need to reset:
</span>    <span class="n">need_restart</span> <span class="o">:=</span>
        <span class="p">(</span><span class="o">!</span><span class="n">initialized</span><span class="p">)</span> <span class="n">or</span>
        <span class="p">(</span><span class="n">tid_timed_out</span><span class="p">)</span> <span class="n">or</span>
        <span class="p">(</span><span class="n">same_iface</span> <span class="n">and</span> <span class="n">first_frame</span> <span class="n">and</span> <span class="n">not_previous_tid</span><span class="p">)</span> <span class="n">or</span>
        <span class="p">(</span><span class="n">iface_switch_allowed</span> <span class="n">and</span> <span class="n">first_frame</span> <span class="n">and</span> <span class="n">non_wrapped_tid</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">need_restart</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">initialized</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">iface_index</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">iface_index</span><span class="p">;</span>
        <span class="n">current_transfer_id</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span><span class="p">;</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">toggle</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frame</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current_transfer_id</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>                       <span class="c1">// Ignore this frame, since the start of the transfer has already been missed
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">iface_index</span> <span class="o">!=</span> <span class="n">iface_index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>  <span class="c1">// Wrong interface, ignore
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">toggle</span> <span class="o">!=</span> <span class="n">toggle</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>  <span class="c1">// Unexpected toggle bit, ignore
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span> <span class="o">!=</span> <span class="n">current_transfer_id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>  <span class="c1">// Unexpected transfer ID, ignore
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first_frame</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this_transfer_timestamp</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">toggle</span> <span class="o">:=</span> <span class="o">!</span><span class="n">toggle</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">last_frame</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// CRC validation for multi-frame transfers is intentionally omitted for brevity
</span>        <span class="n">processTransfer</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="p">...);</span>

        <span class="n">current_transfer_id</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
        <span class="n">toggle</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="state-update-in-a-non-redundant-interface-configuration">State update in a non-redundant interface configuration</h3>

<p>The following pseudocode demonstrates the transfer reception process for
a configuration with a non-redundant CAN bus interface.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Constants:
</span><span class="n">tid_timeout</span> <span class="o">:=</span> <span class="mi">2</span> <span class="n">seconds</span><span class="p">;</span>

<span class="c1">// State variables:
</span><span class="n">initialized</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">payload</span><span class="p">;</span>
<span class="n">this_transfer_timestamp</span><span class="p">;</span>
<span class="n">current_transfer_id</span><span class="p">;</span>
<span class="n">toggle</span><span class="p">;</span>

<span class="n">function</span> <span class="nf">receiveFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resolving the state flags:
</span>    <span class="n">tid_timed_out</span> <span class="o">:=</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">this_transfer_timestamp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tid_timeout</span><span class="p">;</span>
    <span class="n">first_frame</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">start_of_transfer</span><span class="p">;</span>
    <span class="n">not_previous_tid</span> <span class="o">:=</span> <span class="n">computeForwardDistance</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span><span class="p">,</span> <span class="n">current_transfer_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Using the state flags from above, deciding whether we need to reset:
</span>    <span class="n">need_restart</span> <span class="o">:=</span>
        <span class="p">(</span><span class="o">!</span><span class="n">initialized</span><span class="p">)</span> <span class="n">or</span>
        <span class="p">(</span><span class="n">tid_timed_out</span><span class="p">)</span> <span class="n">or</span>
        <span class="p">(</span><span class="n">first_frame</span> <span class="n">and</span> <span class="n">not_previous_tid</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">need_restart</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">initialized</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">current_transfer_id</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span><span class="p">;</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">toggle</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frame</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current_transfer_id</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>                       <span class="c1">// Ignore this frame, since the start of the transfer has already been missed
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">toggle</span> <span class="o">!=</span> <span class="n">toggle</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>  <span class="c1">// Unexpected toggle bit, ignore
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">transfer_id</span> <span class="o">!=</span> <span class="n">current_transfer_id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>  <span class="c1">// Unexpected transfer ID, ignore
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first_frame</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this_transfer_timestamp</span> <span class="o">:=</span> <span class="n">frame</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">toggle</span> <span class="o">:=</span> <span class="o">!</span><span class="n">toggle</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">last_frame</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// CRC validation for multi-frame transfers is intentionally omitted for brevity
</span>        <span class="n">processTransfer</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="p">...);</span>

        <span class="n">current_transfer_id</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
        <span class="n">toggle</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="can-bus-requirements">CAN bus requirements</h2>

<p>The chapter dedicated to <a href="/Specification/8._Hardware_design_recommendations">hardware design recommendations</a> contains
important information concerning CAN bus bit rate, connectors, and other properties of the physical layer
of the protocol.</p>

<h3 id="can-controller-driver-software">CAN controller driver software</h3>

<p>Multi-frame transfers use identical CAN ID for all frames of the transfer, and
DroneCAN requires that all frames of a multi-frame transfer should be transmitted in order.
Therefore, the CAN controller driver software must ensure that
<em>CAN frames with identical CAN ID must be transmitted in their order of appearance in the TX queue</em>.
Some hardware will not meet this requirement by default, so the designer must take special care to
ensure correct behavior, and apply workarounds if necessary.</p>
